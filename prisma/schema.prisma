// prisma/schema.prisma
// =====================================================
// Sparkle Universe Complete Prisma Schema
// Fixes for confirmed issues from comprehensive review
// Version 4.6 - Performance Optimization & Query Strategy Release
// Changes: Added strategic composite indexes for common query patterns,
//          Enhanced User model documentation with query strategies,
//          Added JSON GIN index requirements documentation,
//          Introduced query complexity indicators
// Previous: v4.2 - Index Optimization & Standardization Release
// =====================================================

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["fullTextSearchPostgres", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgcrypto, pg_trgm]
}

// =====================================================
// ENUMS
// =====================================================

enum UserRole {
  USER
  MODERATOR
  ADMIN
  CREATOR
  VERIFIED_CREATOR
  SYSTEM
}

enum UserStatus {
  PENDING_VERIFICATION
  ACTIVE
  SUSPENDED
  BANNED
  DELETED
}

enum NotificationType {
  POST_LIKED
  POST_COMMENTED
  COMMENT_LIKED
  USER_FOLLOWED
  ACHIEVEMENT_UNLOCKED
  LEVEL_UP
  MENTION
  SYSTEM
  GROUP_INVITE
  GROUP_POST
  EVENT_REMINDER
  WATCH_PARTY_INVITE
  DIRECT_MESSAGE
  YOUTUBE_PREMIERE
  QUEST_COMPLETE
  TRADE_REQUEST
  CONTENT_FEATURED
  MILESTONE_REACHED
}

enum ReactionType {
  LIKE
  LOVE
  FIRE
  SPARKLE
  MIND_BLOWN
  LAUGH
  CRY
  ANGRY
  CUSTOM
}

enum ReportReason {
  SPAM
  INAPPROPRIATE
  HARASSMENT
  MISINFORMATION
  COPYRIGHT
  NSFW
  HATE_SPEECH
  SELF_HARM
  OTHER
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
  ESCALATED
  AUTO_APPROVED
  SHADOW_BANNED
  UNDER_REVIEW
}

enum ContentType {
  BLOG
  LIVE_BLOG
  POLL
  VIDEO_REVIEW
  FAN_ART
  THEORY_THREAD
  SERIES
  TUTORIAL
  NEWS
}

enum ContentStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  ARCHIVED
  DELETED
}

enum BadgeRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
  LIMITED_EDITION
  SEASONAL
}

enum QuestType {
  DAILY
  WEEKLY
  MONTHLY
  SPECIAL
  ACHIEVEMENT
  SEASONAL
  COMMUNITY
  CREATOR
}

enum QuestStatus {
  AVAILABLE
  IN_PROGRESS
  COMPLETED
  CLAIMED
  EXPIRED
  LOCKED
}

enum TradeStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
  EXPIRED
  COMPLETED
  DISPUTED
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  DELETED
}

enum EventType {
  WATCH_PARTY
  COMMUNITY_MEETUP
  CONTEST
  PREMIERE
  AMA
  SPECIAL
  TOURNAMENT
  WORKSHOP
}

enum EventStatus {
  DRAFT
  SCHEDULED
  LIVE
  ENDED
  CANCELLED
}

enum GroupVisibility {
  PUBLIC
  PRIVATE
  INVITE_ONLY
  HIDDEN
}

enum GroupMemberRole {
  MEMBER
  MODERATOR
  ADMIN
  OWNER
}

enum CacheType {
  USER_PROFILE
  POST_CONTENT
  FEED
  TRENDING
  LEADERBOARD
  STATS
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  PERMISSION_CHANGE
  MODERATION_ACTION
  SYSTEM_ACTION
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum SubscriptionTier {
  FREE
  SPARKLE_FAN
  SPARKLE_CREATOR
  SPARKLE_LEGEND
}

enum AuthProvider {
  LOCAL
  GOOGLE
  GITHUB
  TWITTER
  DISCORD
}

// Currency Configuration
// All monetary values use Decimal(19,4) for precision:
// - 19 total digits
// - 4 decimal places
// - Supports values up to 999,999,999,999,999.9999

// =====================================================
// CORE MODELS
// =====================================================

// =====================================================
// USER MODEL - PERFORMANCE CRITICAL
// =====================================================
// 
// QUERY COMPLEXITY: EXTREME (70+ relations)
// 
// OPTIMIZATION STRATEGIES:
// 1. ALWAYS use select/include to load only needed data
// 2. Use separate queries for different feature domains
// 3. Consider GraphQL-style field resolvers
// 4. Monitor query performance with these patterns:
//
// GOOD: prisma.user.findMany({ 
//   select: { id: true, username: true, profile: true }
// })
//
// BAD: prisma.user.findMany({ include: { _count: true } })
//
// COMMON QUERY PATTERNS:
// - Basic Profile: id, username, image, role, status
// - Extended Profile: + profile, stats, achievements
// - Social Features: + followers, following counts
// - Content Creator: + posts (limited), subscription
// - Full Admin View: Use multiple queries, not single include
// =====================================================
model User {
  id                String     @id @default(cuid())
  email             String     @unique @db.VarChar(255)
  username          String     @unique @db.VarChar(50)
  hashedPassword    String     @default("")
  authProvider      AuthProvider @default(LOCAL)
  emailVerified     DateTime?
  phoneNumber       String?  // Will be encrypted at application level
  phoneNumberHash   String?  @unique // For lookups
  phoneVerified     DateTime?
  image             String?
  bio               String?    @db.Text
  role              UserRole   @default(USER)
  status            UserStatus @default(PENDING_VERIFICATION)
  verified          Boolean    @default(false)
  verifiedAt        DateTime?
  banned            Boolean    @default(false)
  banReason         String?
  banExpiresAt      DateTime?
  experience        Int        @default(0)
  level             Int        @default(1)
  sparklePoints     Int        @default(0)
  premiumPoints     Int        @default(0)
  reputationScore   Int        @default(0)
  lastSeenAt        DateTime?
  onlineStatus      Boolean    @default(false)
  twoFactorEnabled  Boolean    @default(false)
  twoFactorSecret   String?  // Will be encrypted at application level
  twoFactorBackupCodes String[] // Encrypted backup codes
  // Security & Authentication Fields
  resetPasswordToken       String?   @unique
  resetPasswordExpires     DateTime?
  emailVerificationToken   String?   @unique
  emailVerificationExpires DateTime?
  accountLockoutAttempts   Int       @default(0)
  accountLockedUntil       DateTime?
  lastPasswordChangedAt    DateTime?
  lastFailedLoginAt        DateTime?
  failedLoginAttempts      Int       @default(0)
  preferredLanguage String     @default("en")
  timezone          String     @default("UTC")
  version           Int        @default(0) // For optimistic locking
  deleted           Boolean    @default(false)
  deletedAt         DateTime?
  deletedBy         String?
  createdAt         DateTime   @default(now())
  updatedAt         DateTime   @updatedAt

  // --- Creator Monetization Fields ---
  creatorRevenueShare Decimal   @default(0.7000) @db.Decimal(19, 4)  // FIXED: Standardized precision
  totalRevenueEarned  BigInt    @default(0)
  lastPayoutDate      DateTime?

  // Relations
  accounts                 Account[]
  sessions                 Session[]
  profile                  Profile?
  stats                    UserStats?
  balance                  UserBalance?
  subscription             UserSubscription?
  posts                    Post[]                    @relation("UserPosts")
  comments                 Comment[]                 @relation("UserComments")
  reactions                Reaction[]
  following                Follow[]                  @relation("follower")
  followers                Follow[]                  @relation("following")
  blockedUsers             Block[]                   @relation("blocker")
  blockedBy                Block[]                   @relation("blocked")
  achievements             UserAchievement[]
  notifications            Notification[]            @relation("notificationUser")
  notificationsSent        Notification[]            @relation("notificationActor")
  notificationPrefs        NotificationPreference?
  xpLogs                   XpLog[]
  currencyTransactions     CurrencyTransaction[]
  inventory                UserInventory[]
  tradesInitiated          Trade[]                   @relation("tradeInitiator")
  tradesReceived           Trade[]                   @relation("tradeRecipient")
  questProgress            UserQuest[]
  youtubeChannels          YoutubeChannel[]
  hostedWatchParties       WatchParty[]
  watchPartyParticipants   WatchPartyParticipant[]
  videoClips               VideoClip[]
  playlists                Playlist[]
  playlistItems            PlaylistItem[]
  groupsOwned              Group[]                   @relation("GroupOwner")
  groupMemberships         GroupMember[]
  eventsHosted             Event[]                   @relation("EventHost")
  eventAttendances         EventAttendee[]
  conversationsCreated     Conversation[]            @relation("ConversationCreator")
  conversationParticipants ConversationParticipant[]
  messages                 Message[]
  messageReads             MessageRead[]
  websocketSessions        WebsocketSession[]
  chatRoomsCreated         ChatRoom[]
  chatMessages             ChatMessage[]
  collaborativeSpacesOwned CollaborativeSpace[]
  spaceCollaborations      SpaceCollaborator[]
  activityStreams          ActivityStream[]
  fanArtSubmissions        FanArtSubmission[]
  mediaFiles               MediaFile[]
  experimentAssignments    ExperimentAssignment[]
  moderationReviews        AiModerationQueue[]       @relation("moderationReviewer")
  reports                  Report[]                  @relation("reporter")
  reportedReports          Report[]                  @relation("reportedUser")  // NEW
  reportResolutions        Report[]                  @relation("resolver")
  siteSettingUpdates       SiteSetting[]
  postSeries               PostSeries[]
  auditLogs                AuditLog[]
  apiKeys                  ApiKey[]
  webhooks                 Webhook[]
  contentRevisions         PostRevision[]
  searchHistory            SearchHistory[]
  viewHistory              ViewHistory[]
  loginHistory             LoginHistory[]
  securityAlerts           SecurityAlert[]
  referralCodeUsed         Referral?                 @relation("referredUser")
  referralsMade            Referral[]                @relation("referrer")
  pollVotes                PollVote[]
  bookmarks                Bookmark[]
  bookmarkFolders          BookmarkFolder[]
  watchPartyChatMessages   WatchPartyChat[]
  groupPosts               GroupPost[]
  analyticsEvents          AnalyticsEvent[]

  // --- Mention Relations ---
  mentionsMade     Mention[] @relation("mentionsMade")
  mentionsReceived Mention[] @relation("mentionsReceived")

  // --- AI Relations ---
  aiRecommendations        AiRecommendation[]
  aiContentSuggestions     AiContentSuggestion[]
  aiPreference             UserAiPreference?
  aiAssistantConversations AiAssistantConversation[]

  // --- Creator Monetization Relations ---
  payouts            CreatorPayout[]
  sentFanFunding     FanFunding[]     @relation("sentFanFunding")
  receivedFanFunding FanFunding[]     @relation("receivedFanFunding")
  revenueShares      RevenueShare[]
  sentTips           TipTransaction[] @relation("sentTips")
  receivedTips       TipTransaction[] @relation("receivedTips")

  // --- Email Campaign Relations ---
  createdEmailCampaigns  EmailCampaign[]         @relation("campaignCreator")
  newsletterSubscription NewsletterSubscription?
  createdEmailTemplates  EmailTemplate[]         @relation("templateCreator")

  // --- Scheduling Relations ---
  recurringSchedules RecurringSchedule[]

  // OPTIMIZED INDEXES - Remove redundant, combine where possible
  @@index([email])
  @@index([username])
  // @@index([deleted, status, role, lastSeenAt(sort: Desc)])  // Keep most comprehensive
  // REMOVED: @@index([deleted, status, lastSeenAt, onlineStatus]) // Redundant with above
  @@index([deleted, level, experience(sort: Desc)])
  @@index([status, onlineStatus, lastSeenAt(sort: Desc)])
  @@index([createdAt])
  @@index([role, verified, createdAt(sort: Desc)])
  // OPTIMIZED: Combine related indexes
  @@index([deleted, status, role, onlineStatus, lastSeenAt(sort: Desc)])  // NEW: Combined index
  @@map("users")
}

model UserStats {
  id                  String    @id @default(cuid())
  userId              String    @unique
  totalPosts          Int       @default(0)
  totalComments       Int       @default(0)
  totalLikesReceived  Int       @default(0)
  totalLikesGiven     Int       @default(0)
  totalViews          Int       @default(0)
  totalFollowers      Int       @default(0)
  totalFollowing      Int       @default(0)
  totalWatchTime      BigInt    @default(0) // In seconds
  streakDays          Int       @default(0)
  longestStreak       Int       @default(0)
  lastActivityAt      DateTime?
  profileViews        Int       @default(0)
  engagementRate      Float     @default(0)
  contentQualityScore Float     @default(0)
  updatedAt           DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([totalFollowers])
  @@index([engagementRate])
  @@map("user_stats")
}

model UserBalance {
  id                String    @id @default(cuid())
  userId            String    @unique
  sparklePoints     Int       @default(0)
  premiumPoints     Int       @default(0)
  frozenPoints      Int       @default(0) // Points in pending trades
  lifetimeEarned    Int       @default(0)
  lifetimeSpent     Int       @default(0)
  version           Int       @default(0) // For optimistic locking
  lastTransactionAt DateTime?
  updatedAt         DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_balances")
}

model UserSubscription {
  id               String           @id @default(cuid())
  userId           String           @unique
  tier             SubscriptionTier @default(FREE)
  status           PaymentStatus    @default(PENDING)
  startDate        DateTime         @default(now())
  endDate          DateTime?
  cancelledAt      DateTime?
  paymentMethod    String?
  stripeCustomerId String?
  stripeSubId      String?
  autoRenew        Boolean          @default(true)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([endDate])
  @@map("user_subscriptions")
}

// =====================================================
// PROFILE MODEL - JSON INDEX REQUIREMENTS
// =====================================================
// 
// JSON GIN INDEXES REQUIRED (via migration):
// - CREATE INDEX idx_profile_theme ON profiles USING GIN (themePreference);
// - CREATE INDEX idx_profile_notifications ON profiles USING GIN (notificationSettings);
// - CREATE INDEX idx_profile_privacy ON profiles USING GIN (privacySettings);
// - CREATE INDEX idx_profile_social ON profiles USING GIN (socialLinks);
// =====================================================
model Profile {
  id                   String    @id @default(cuid())
  userId               String    @unique
  displayName          String?
  location             String?
  website              String?
  twitterUsername      String?
  instagramUsername    String?
  tiktokUsername       String?
  discordUsername      String?
  youtubeChannelId     String?
  youtubeChannelUrl    String?
  youtubeChannelData   Json?     // INDEX: GIN index recommended
  bannerImage          String?
  themePreference      Json?     // INDEX: GIN index recommended
  notificationSettings Json      @default("{}") // INDEX: GIN index recommended
  privacySettings      Json      @default("{}") // INDEX: GIN index recommended
  // v4.1: Extracted frequently queried fields from JSON
  profileVisibility    String    @default("public") // "public", "followers", "private"
  contentVisibility    String    @default("public") // "public", "followers", "private"
  allowDirectMessages  Boolean   @default(true)
  featuredBadges       String[]
  showcasedPosts       String[]
  customCss            String?   @db.Text
  customHtml           String?   @db.Text
  socialLinks          Json?     // INDEX: GIN index recommended
  interests            String[]
  skills               String[]
  pronouns             String?
  birthdate            DateTime?
  joinedCommunityAt    DateTime  @default(now())
  profileCompleted     Boolean   @default(false)
  profileCompleteness  Int       @default(0)
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([youtubeChannelId])
  @@index([profileCompleted])
  // v4.1: New indexes for extracted fields
  @@index([profileVisibility])
  @@index([contentVisibility])
  @@map("profiles")
}

model Account {
  id                String   @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refreshToken      String?  @db.Text
  accessToken       String?  @db.Text
  expiresAt         BigInt?
  tokenType         String?
  scope             String?
  idToken           String?  @db.Text
  sessionState      String?
  oauthTokenSecret  String?
  oauthToken        String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  ipAddress    String?
  userAgent    String?  @db.Text
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sessionToken])
  @@index([expires])
  @@map("sessions")
}

model LoginHistory {
  id        String   @id @default(cuid())
  userId    String
  ipAddress String
  userAgent String   @db.Text
  location  String?
  success   Boolean
  reason    String?
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@map("login_history")
}

model SecurityAlert {
  id          String    @id @default(cuid())
  userId      String
  type        String
  severity    String
  title       String
  description String    @db.Text
  resolved    Boolean   @default(false)
  resolvedAt  DateTime?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, resolved])
  @@index([severity])
  @@map("security_alerts")
}

model ApiKey {
  id          String    @id @default(cuid())
  userId      String
  name        String
  key         String    @unique
  permissions String[]
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  revokedAt   DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([key])
  @@map("api_keys")
}

model Webhook {
  id            String    @id @default(cuid())
  userId        String
  name          String
  url           String
  secret        String
  events        String[]
  active        Boolean   @default(true)
  failureCount  Int       @default(0)
  lastTriggered DateTime?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([active])
  @@map("webhooks")
}

model Block {
  id        String   @id @default(cuid())
  blockerId String
  blockedId String
  reason    String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  blocker User @relation("blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("blocks")
}

model NotificationPreference {
  id                 String   @id @default(cuid())
  userId             String   @unique
  emailNotifications Boolean  @default(true)
  pushNotifications  Boolean  @default(true)
  smsNotifications   Boolean  @default(false)
  // v4.1: Extracted frequently queried fields
  emailDigestFrequency String   @default("weekly") // "never", "daily", "weekly", "monthly"
  pushEnabled        Boolean  @default(true) // Master push switch
  postLikes          Boolean  @default(true)
  postComments       Boolean  @default(true)
  newFollowers       Boolean  @default(true)
  mentions           Boolean  @default(true)
  directMessages     Boolean  @default(true)
  groupInvites       Boolean  @default(true)
  eventReminders     Boolean  @default(true)
  marketingEmails    Boolean  @default(false)
  weeklyDigest       Boolean  @default(true)
  quietHoursStart    String? // Format: "HH:MM"
  quietHoursEnd      String? // Format: "HH:MM"
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  // v4.1: New indexes for extracted fields
  @@index([emailDigestFrequency])
  @@index([pushEnabled])
  @@map("notification_preferences")
}

model Referral {
  id             String    @id @default(cuid())
  referrerId     String
  referredUserId String?   @unique
  referralCode   String    @unique
  referredEmail  String?
  status         String    @default("PENDING")
  rewardClaimed  Boolean   @default(false)
  rewardAmount   Int       @default(100)
  expiresAt      DateTime?
  completedAt    DateTime?
  createdAt      DateTime  @default(now())

  // Relations
  referrer     User  @relation("referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referredUser User? @relation("referredUser", fields: [referredUserId], references: [id], onDelete: SetNull)

  @@index([referrerId])
  @@index([referralCode])
  @@index([status])
  @@map("referrals")
}

// =====================================================
// CONTENT MODELS
// =====================================================

model Category {
  id           String    @id @default(cuid())
  name         String    @db.VarChar(255)
  slug         String    @unique
  description  String?   @db.Text
  icon         String?
  color        String?
  parentId     String?
  postCount    Int       @default(0)
  displayOrder Int       @default(0)
  isActive     Boolean   @default(true)
  metadata     Json?
  deleted      Boolean   @default(false)
  deletedAt    DateTime?
  deletedBy    String?
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  // Relations
  parent   Category?  @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children Category[] @relation("CategoryHierarchy")
  posts    Post[]

  @@index([slug])
  @@index([parentId])
  @@index([isActive, deleted])
  @@map("categories")
}

// =====================================================
// POST MODEL - JSON INDEX REQUIREMENTS
// =====================================================
// 
// QUERY COMPLEXITY: HIGH (Multiple JSON fields and relations)
// 
// JSON GIN INDEXES REQUIRED (via migration):
// - CREATE INDEX idx_post_content ON posts USING GIN (content);
// - CREATE INDEX idx_post_youtube_data ON posts USING GIN (youtubeVideoData);
// - CREATE INDEX idx_post_sponsor ON posts USING GIN (sponsorInfo);
// 
// For specific JSON paths:
// - CREATE INDEX idx_post_content_type ON posts ((content->>'type'));
// - CREATE INDEX idx_post_content_blocks ON posts ((content->'blocks'));
// =====================================================
model Post {
  id                 String           @id @default(cuid())
  slug               String           @unique
  title              String           @db.VarChar(500)
  content            Json             // INDEX: GIN index required
  contentType        ContentType      @default(BLOG)
  contentStatus      ContentStatus    @default(DRAFT)
  excerpt            String?          @db.Text
  coverImage         String?
  coverImageAlt      String?
  authorId           String?
  authorName         String?          // Preserved author name for deleted users
  categoryId         String?
  seriesId           String?
  seriesOrder        Int?
  published          Boolean          @default(false)
  featured           Boolean          @default(false)
  editorsPick        Boolean          @default(false)
  sponsoredContent   Boolean          @default(false)
  sponsorInfo        Json?            // INDEX: GIN index recommended
  isPinned           Boolean          @default(false)
  pinnedUntil        DateTime?
  isDraft            Boolean          @default(true)
  version            Int              @default(1)
  parentVersionId    String?
  collaborators      String[] // User IDs who can edit
  youtubeVideoId     String?
  youtubeVideoData   Json?            // INDEX: GIN index recommended
  views              Int              @default(0)
  uniqueViews        Int              @default(0)
  readingTime        Int? // In minutes
  wordCount          Int?
  metaTitle          String?          @db.VarChar(160)
  metaDescription    String?          @db.VarChar(320)
  metaKeywords       String[]
  ogImage            String?
  canonicalUrl       String?
  customSlug         Boolean          @default(false)
  allowComments      Boolean          @default(true)
  moderationStatus   ModerationStatus @default(PENDING)
  moderationNotes    String?          @db.Text
  scheduledPublishAt DateTime?
  publishedAt        DateTime?
  lastEditedAt       DateTime?
  archivedAt         DateTime?
  deleted            Boolean          @default(false)
  deletedAt          DateTime?
  deletedBy          String?
  createdAt          DateTime         @default(now())
  updatedAt          DateTime         @updatedAt

  // --- AI Generated Content Fields ---
  aiGenerated     Boolean @default(false)
  aiModel         String?
  aiPrompt        String?
  aiRevisionCount Int     @default(0)

  // Relations - Updated to handle user deletion gracefully
  author              User?               @relation("UserPosts", fields: [authorId], references: [id], onDelete: SetNull)
  category            Category?           @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  series              PostSeries?         @relation(fields: [seriesId], references: [id], onDelete: SetNull)
  parentVersion       Post?               @relation("PostVersions", fields: [parentVersionId], references: [id], onDelete: SetNull)
  childVersions       Post[]              @relation("PostVersions")
  tags                PostTag[]
  comments            Comment[]           @relation("PostComments")
  reactions           Reaction[]
  poll                Poll?
  fanArtGallery       FanArtGallery?
  stats               PostStats?
  revisions           PostRevision[]
  viewHistory         ViewHistory[]
  relatedPosts        PostRelation[]      @relation("relatedPost")
  relatedTo           PostRelation[]      @relation("mainPost")
  mentions            Mention[]
  bookmarks           Bookmark[]
  reports             Report[]            @relation("reportedPost")
  aiModerationEntries AiModerationQueue[] @relation("moderatedPost")

  // --- Scheduling Relations ---
  publishQueueEntry PublishQueue?

  @@index([slug])
  @@index([authorId, published, publishedAt(sort: Desc)])
  @@index([categoryId, contentStatus, featured])
  @@index([published, featured, publishedAt(sort: Desc)])
  @@index([contentType, published])
  @@index([deleted, published, publishedAt(sort: Desc)])
  @@index([moderationStatus, createdAt(sort: Desc)])
  // v4.1: New performance indexes
  @@index([authorId, contentStatus, deleted]) // Author's content management
  @@index([categoryId, published, views(sort: Desc)]) // Popular posts by category
  @@index([featured, published, createdAt(sort: Desc)]) // Featured content feed
  // v4.3: Additional composite indexes
  @@index([authorId, isDraft, createdAt(sort: Desc)]) // Author's drafts
  @@index([scheduledPublishAt, contentStatus]) // Publishing queue
  @@index([contentType, moderationStatus, createdAt(sort: Desc)]) // Moderation by type
  @@map("posts")
}

// =====================================================
// SCHEDULING MODELS
// =====================================================

model ScheduledAction {
  id            String    @id @default(cuid())
  actionType    String // "publish_post", "send_notification", "trigger_event"
  entityType    String // "post", "user", "group"
  entityId      String
  scheduledFor  DateTime
  status        String    @default("PENDING") // "PENDING", "PROCESSING", "COMPLETED", "FAILED", "CANCELLED"
  parameters    Json // Action-specific parameters
  retryCount    Int       @default(0)
  maxRetries    Int       @default(3)
  lastAttempt   DateTime?
  nextRetry     DateTime?
  failureReason String?
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  @@index([scheduledFor, status])
  @@index([entityType, entityId])
  @@map("scheduled_actions")
}

model RecurringSchedule {
  id             String    @id @default(cuid())
  userId         String
  entityType     String // "post", "event", "newsletter"
  entityId       String
  recurrenceRule String // RRULE format
  startDate      DateTime
  endDate        DateTime?
  lastRun        DateTime?
  nextRun        DateTime
  parameters     Json
  isActive       Boolean   @default(true)
  createdAt      DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, isActive, nextRun])
  @@index([nextRun])
  @@map("recurring_schedules")
}

model PublishQueue {
  id           String    @id @default(cuid())
  postId       String    @unique
  scheduledFor DateTime
  status       String    @default("SCHEDULED") // "SCHEDULED", "PUBLISHED", "FAILED"
  attempts     Int       @default(0)
  error        String?
  processedAt  DateTime?
  createdAt    DateTime  @default(now())

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([scheduledFor, status])
  @@map("publish_queue")
}

model PostStats {
  id                 String   @id @default(cuid())
  postId             String   @unique
  viewCount          Int      @default(0)
  uniqueViewCount    Int      @default(0)
  likeCount          Int      @default(0)
  loveCount          Int      @default(0)
  fireCount          Int      @default(0)
  totalReactionCount Int      @default(0)
  commentCount       Int      @default(0)
  shareCount         Int      @default(0)
  bookmarkCount      Int      @default(0)
  avgReadTime        Float    @default(0) // In seconds
  bounceRate         Float    @default(0)
  engagementRate     Float    @default(0)
  lastCalculatedAt   DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([viewCount])
  @@index([totalReactionCount])
  @@index([engagementRate])
  @@map("post_stats")
}

model PostRevision {
  id          String   @id @default(cuid())
  postId      String
  editorId    String
  title       String   @db.VarChar(500)
  content     Json
  changeNote  String?  @db.Text
  version     Int
  isPublished Boolean  @default(false)
  createdAt   DateTime @default(now())

  // Relations
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  editor User @relation(fields: [editorId], references: [id], onDelete: Cascade)

  @@index([postId, version])
  @@index([editorId])
  // v4.3: Added missing index
  @@index([postId])
  @@map("post_revisions")
}

model PostRelation {
  id            String   @id @default(cuid())
  postId        String
  relatedPostId String
  relationType  String // "sequel", "prequel", "related", "translation"
  sortOrder     Int      @default(0)
  createdAt     DateTime @default(now())

  // Relations
  post        Post @relation("mainPost", fields: [postId], references: [id], onDelete: Cascade)
  relatedPost Post @relation("relatedPost", fields: [relatedPostId], references: [id], onDelete: Cascade)

  @@unique([postId, relatedPostId])
  @@index([postId])
  @@index([relatedPostId])
  @@map("post_relations")
}

model PostSeries {
  id          String    @id @default(cuid())
  title       String
  slug        String    @unique
  description String?   @db.Text
  authorId    String?
  authorName  String?   // Preserved author name for deleted users
  coverImage  String?
  bannerImage String?
  totalParts  Int       @default(0)
  completed   Boolean   @default(false)
  featured    Boolean   @default(false)
  metadata    Json?
  deleted     Boolean   @default(false)
  deletedAt   DateTime?
  deletedBy   String?
  createdAt   DateTime  @default(now())
  updatedAt   DateTime  @updatedAt

  // Relations - Updated to handle user deletion
  author User?  @relation(fields: [authorId], references: [id], onDelete: SetNull)
  posts  Post[]

  @@index([authorId])
  @@index([slug])
  @@index([featured, deleted])
  @@map("post_series")
}

model Tag {
  id          String    @id @default(cuid())
  name        String    @unique @db.VarChar(255)
  slug        String    @unique @db.VarChar(255)
  description String?   @db.Text
  color       String?
  icon        String?
  postCount   Int       @default(0)
  featured    Boolean   @default(false)
  category    String?
  synonyms    String[]
  deleted     Boolean   @default(false)
  deletedAt   DateTime?
  deletedBy   String?
  createdAt   DateTime  @default(now())

  // Relations
  posts PostTag[]

  @@index([name])
  @@index([slug])
  @@index([featured, deleted])
  @@index([postCount(sort: Desc)])
  @@map("tags")
}

model PostTag {
  postId    String
  tagId     String
  addedBy   String?
  createdAt DateTime @default(now())

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}

// =====================================================
// COMMENT MODEL - ENHANCED INDEXES
// =====================================================
// 
// QUERY PATTERNS:
// - Thread navigation: parentId + createdAt
// - User's comments: authorId + deleted + createdAt
// - Post comments: postId + deleted + createdAt
// =====================================================
model Comment {
  id               String           @id @default(cuid())
  content          String           @db.Text
  postId           String
  authorId         String?
  authorName       String?          // Preserved author name for deleted users
  parentId         String?
  youtubeTimestamp Int?
  quotedTimestamp  String? // For quoting specific video moments
  edited           Boolean          @default(false)
  editedAt         DateTime?
  editHistory      Json[] // Store previous versions
  deleted          Boolean          @default(false)
  deletedAt        DateTime?
  deletedBy        String?
  pinned           Boolean          @default(false)
  featured         Boolean          @default(false)
  moderationStatus ModerationStatus @default(AUTO_APPROVED)
  moderationNotes  String?
  ipAddress        String?
  userAgent        String?
  version          Int              @default(0)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations - Updated to handle user deletion
  post      Post       @relation("PostComments", fields: [postId], references: [id], onDelete: Cascade)
  author    User?      @relation("UserComments", fields: [authorId], references: [id], onDelete: SetNull)
  parent    Comment?   @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]  @relation("CommentReplies")
  reactions Reaction[]
  mentions  Mention[]
  reports   Report[]   @relation("reportedComment")

  @@index([postId, deleted, createdAt(sort: Desc)])
  @@index([authorId])
  @@index([parentId])
  @@index([youtubeTimestamp])
  @@index([moderationStatus, deleted])
  // v4.1: New performance indexes
  @@index([postId, parentId, createdAt]) // Thread navigation
  @@index([authorId, deleted, createdAt(sort: Desc)]) // User's comments
  // v4.3: Additional composite indexes
  @@index([postId, parentId, deleted, createdAt]) // Complete thread queries
  @@index([postId, pinned, createdAt(sort: Desc)]) // Pinned comments first
  @@map("comments")
}

model Reaction {
  id          String       @id @default(cuid())
  type        ReactionType
  postId      String?
  commentId   String?
  userId      String
  customEmoji String? // For CUSTOM type
  metadata    Json?
  createdAt   DateTime     @default(now())

  // Relations
  post    Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId, type])
  @@unique([commentId, userId, type])
  @@index([postId])
  @@index([commentId])
  @@index([userId])
  @@index([type])
  @@map("reactions")
}

model Mention {
  id           String   @id @default(cuid())
  mentionerId  String
  mentionedId  String
  postId       String?
  commentId    String?
  context      String?  @db.Text
  acknowledged Boolean  @default(false)
  createdAt    DateTime @default(now())

  // Relations
  mentioner User     @relation("mentionsMade", fields: [mentionerId], references: [id], onDelete: Cascade)
  mentioned User     @relation("mentionsReceived", fields: [mentionedId], references: [id], onDelete: Cascade)
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@index([mentionedId])
  @@index([postId])
  @@index([commentId])
  @@map("mentions")
}

model Bookmark {
  id        String   @id @default(cuid())
  userId    String
  postId    String
  folderId  String?
  notes     String?  @db.Text
  tags      String[]
  createdAt DateTime @default(now())

  // Relations
  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  post   Post            @relation(fields: [postId], references: [id], onDelete: Cascade)
  folder BookmarkFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)

  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
  @@index([folderId])
  @@map("bookmarks")
}

model BookmarkFolder {
  id          String   @id @default(cuid())
  userId      String
  name        String
  description String?
  color       String?
  icon        String?
  isPublic    Boolean  @default(false)
  sortOrder   Int      @default(0)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookmarks Bookmark[]

  @@unique([userId, name])
  @@index([userId])
  @@map("bookmark_folders")
}

model Follow {
  id             String   @id @default(cuid())
  followerId     String
  followingId    String
  notifyNewPosts Boolean  @default(true)
  notifyActivity Boolean  @default(false)
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  // Relations
  follower  User @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model ViewHistory {
  id           String   @id @default(cuid())
  userId       String
  postId       String
  viewDuration Int      @default(0) // In seconds
  scrollDepth  Float    @default(0) // Percentage
  referrer     String?
  deviceType   String?
  createdAt    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([postId])
  @@map("view_history")
}

model SearchHistory {
  id             String   @id @default(cuid())
  userId         String?
  query          String
  resultCount    Int      @default(0)
  clickedResults String[]
  searchType     String? // "posts", "users", "tags", etc.
  deviceType     String?
  createdAt      DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([query])
  @@index([createdAt])
  @@map("search_history")
}

// =====================================================
// NOTIFICATION & EMAIL MODELS
// =====================================================

// =====================================================
// NOTIFICATION MODEL - QUERY OPTIMIZATION
// =====================================================
// 
// COMMON QUERIES:
// - User's unread notifications: userId + read + createdAt
// - Priority notifications: userId + priority + read
// - Expired notifications cleanup: expiresAt
// =====================================================
model Notification {
  id          String           @id @default(cuid())
  type        NotificationType
  userId      String
  actorId     String?
  entityId    String?
  entityType  String?
  title       String
  message     String           @db.Text
  data        Json?
  imageUrl    String?
  actionUrl   String?
  priority    Int              @default(0) // 0=low, 1=normal, 2=high
  read        Boolean          @default(false)
  readAt      DateTime?
  clicked     Boolean          @default(false)
  clickedAt   DateTime?
  emailSent   Boolean          @default(false)
  pushSent    Boolean          @default(false)
  smsSent     Boolean          @default(false)
  dismissed   Boolean          @default(false)
  dismissedAt DateTime?
  expiresAt   DateTime?
  createdAt   DateTime         @default(now())
  updatedAt   DateTime         @updatedAt

  // Relations
  user  User  @relation("notificationUser", fields: [userId], references: [id], onDelete: Cascade)
  actor User? @relation("notificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, read, createdAt(sort: Desc)])
  @@index([actorId])
  @@index([type])
  @@index([priority])
  @@index([expiresAt])
  // v4.3: Additional composite indexes
  @@index([userId, priority, read, createdAt(sort: Desc)]) // Priority unread
  @@index([userId, type, createdAt(sort: Desc)]) // By type queries
  // NEW: Add index for cleanup operations
  @@index([expiresAt, dismissed])
  @@map("notifications")
}

model NotificationQueue {
  id           String    @id @default(cuid())
  userId       String
  type         String
  channel      String // "email", "push", "sms"
  payload      Json
  priority     Int       @default(0)
  attempts     Int       @default(0)
  maxAttempts  Int       @default(3)
  scheduledFor DateTime  @default(now())
  processedAt  DateTime?
  failedAt     DateTime?
  error        String?   @db.Text
  createdAt    DateTime  @default(now())

  @@index([scheduledFor, processedAt])
  @@index([userId])
  @@index([priority])
  @@map("notification_queue")
}

model EmailCampaign {
  id              String    @id @default(cuid())
  name            String    @db.VarChar(255)
  subject         String
  templateId      String
  segment         String // Target audience segment
  status          String    @default("DRAFT") // "DRAFT", "SCHEDULED", "SENDING", "SENT"
  scheduledFor    DateTime?
  sentAt          DateTime?
  totalRecipients Int       @default(0)
  delivered       Int       @default(0)
  opened          Int       @default(0)
  clicked         Int       @default(0)
  bounced         Int       @default(0)
  unsubscribed    Int       @default(0)
  content         Json // Campaign variables
  createdBy       String
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  creator   User             @relation("campaignCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  template  EmailTemplate    @relation(fields: [templateId], references: [id], onDelete: Restrict)
  sendQueue EmailSendQueue[]

  @@unique([createdBy, name]) // v4.2: Prevent duplicate campaign names per creator
  @@index([status, scheduledFor])
  @@index([createdBy])
  @@map("email_campaigns")
}

model NewsletterSubscription {
  id         String    @id @default(cuid())
  userId     String    @unique
  subscribed Boolean   @default(true)
  frequency  String    @default("weekly") // "daily", "weekly", "monthly"
  topics     String[] // ["trending", "creator", "gaming", "news"]
  lastSent   DateTime?
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([subscribed, frequency])
  @@map("newsletter_subscriptions")
}

model EmailTemplate {
  id          String   @id @default(cuid())
  name        String   @unique @db.VarChar(255)
  subject     String
  htmlContent String   @db.Text
  textContent String?  @db.Text
  variables   String[] // Available template variables
  category    String // "transactional", "marketing", "notification"
  isActive    Boolean  @default(true)
  version     Int      @default(1)
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  creator   User             @relation("templateCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  campaigns EmailCampaign[]
  sendQueue EmailSendQueue[]

  @@index([category])
  @@index([isActive])
  @@map("email_templates")
}

model EmailSendQueue {
  id         String    @id @default(cuid())
  campaignId String?
  recipient  String
  templateId String
  variables  Json
  status     String    @default("PENDING") // "PENDING", "SENT", "FAILED", "BOUNCED"
  attempts   Int       @default(0)
  sentAt     DateTime?
  failedAt   DateTime?
  error      String?
  createdAt  DateTime  @default(now())

  // Relations
  campaign EmailCampaign? @relation(fields: [campaignId], references: [id], onDelete: Cascade)
  template EmailTemplate  @relation(fields: [templateId], references: [id], onDelete: Cascade)

  @@index([status, attempts])
  @@index([campaignId])
  @@index([recipient])
  @@map("email_send_queue")
}

// =====================================================
// GAMIFICATION & MONETIZATION MODELS
// =====================================================

model Achievement {
  id                  String      @id @default(cuid())
  code                String      @unique
  name                String      @db.VarChar(255)
  description         String?     @db.Text
  shortDescription    String?
  icon                String?
  animatedIcon        String?
  bannerImage         String?
  xpReward            Int         @default(0)
  sparklePointsReward Int         @default(0)
  premiumPointsReward Int         @default(0)
  rarity              BadgeRarity @default(COMMON)
  category            String?
  subcategory         String?
  criteria            Json?
  progressSteps       Int         @default(1)
  isSecret            Boolean     @default(false)
  prerequisiteIds     String[]
  displayOrder        Int         @default(0)
  seasonal            Boolean     @default(false)
  eventBased          Boolean     @default(false)
  limited             Boolean     @default(false)
  maxAchievers        Int? // For limited edition
  expiresAt           DateTime?
  metadata            Json?
  deleted             Boolean     @default(false)
  deletedAt           DateTime?
  deletedBy           String?
  createdAt           DateTime    @default(now())
  updatedAt           DateTime    @updatedAt

  // Relations
  userAchievements UserAchievement[]

  @@index([code])
  @@index([category])
  @@index([rarity])
  @@index([deleted])
  @@map("achievements")
}

model UserAchievement {
  id             String    @id @default(cuid())
  userId         String
  achievementId  String
  progress       Float     @default(0) // 0 to 1
  progressData   Json?
  unlockedAt     DateTime  @default(now())
  showcased      Boolean   @default(false)
  showcaseOrder  Int       @default(0)
  notified       Boolean   @default(false)
  claimedRewards Boolean   @default(false)
  deleted        Boolean   @default(false)
  deletedAt      DateTime?
  deletedBy      String?

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId, showcased])
  @@index([achievementId])
  @@index([deleted])
  @@map("user_achievements")
}

model XpLog {
  id         String   @id @default(cuid())
  userId     String
  amount     Int
  source     String // "post_create", "comment", "like_received", etc.
  sourceId   String? // Reference to the source entity
  reason     String?
  multiplier Float    @default(1)
  bonusXp    Int      @default(0)
  totalXp    Int // Total XP after this transaction
  metadata   Json?
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([source])
  @@map("xp_logs")
}

model LevelConfig {
  level          Int      @id
  requiredXp     Int
  title          String
  perks          String[]
  sparkleReward  Int      @default(0)
  premiumReward  Int      @default(0)
  unlockFeatures String[]
  badgeId        String?
  createdAt      DateTime @default(now())

  @@index([requiredXp])
  @@map("level_configs")
}

model CurrencyTransaction {
  id              String   @id @default(cuid())
  userId          String
  amount          Int
  currencyType    String // "sparkle", "premium"
  transactionType String // "earn", "spend", "transfer", "refund"
  source          String // "achievement", "purchase", "trade", etc.
  sourceId        String?
  description     String?
  referenceId     String?
  referenceType   String?
  balanceBefore   Int
  balanceAfter    Int
  metadata        Json?
  createdAt       DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([transactionType])
  @@index([source])
  @@map("currency_transactions")
}

model CreatorPayout {
  id            String    @id @default(cuid())
  userId        String
  periodStart   DateTime
  periodEnd     DateTime
  totalRevenue  Decimal   @default(0) @db.Decimal(19, 4)
  platformFee   Decimal   @default(0) @db.Decimal(19, 4)
  creatorShare  Decimal   @default(0) @db.Decimal(19, 4)
  taxWithheld   Decimal   @default(0) @db.Decimal(19, 4)
  finalAmount   Decimal   @default(0) @db.Decimal(19, 4)
  payoutMethod  String // "stripe", "paypal", "bank_transfer"
  payoutStatus  String    @default("PENDING") // "PENDING", "PROCESSING", "COMPLETED", "FAILED"
  transactionId String?
  failureReason String?
  scheduledDate DateTime
  processedDate DateTime?
  createdAt     DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, periodStart, periodEnd])
  @@index([payoutStatus])
  @@index([scheduledDate])
  @@map("creator_payouts")
}

model FanFunding {
  id            String   @id @default(cuid())
  senderId      String
  recipientId   String
  amount        Decimal  @db.Decimal(19, 4) // In base currency units
  currency      String   @default("USD")
  message       String?  @db.Text
  isAnonymous   Boolean  @default(false)
  platformFee   Decimal  @default(0) @db.Decimal(19, 4)
  creatorAmount Decimal  @default(0) @db.Decimal(19, 4)
  paymentMethod String // "stripe", "paypal"
  paymentStatus String   @default("PENDING")
  transactionId String?
  failureReason String?
  createdAt     DateTime @default(now())

  // Relations
  sender    User @relation("sentFanFunding", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User @relation("receivedFanFunding", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([senderId])
  @@index([recipientId])
  @@index([paymentStatus])
  @@map("fan_funding")
}

model RevenueShare {
  id             String    @id @default(cuid())
  contentType    String // "post", "video", "stream"
  contentId      String
  creatorId      String
  totalRevenue   Decimal   @default(0) @db.Decimal(19, 4)
  platformShare  Decimal   @default(0) @db.Decimal(19, 4)
  creatorShare   Decimal   @default(0) @db.Decimal(19, 4)
  affiliateShare Decimal   @default(0) @db.Decimal(19, 4)
  calculatedAt   DateTime  @default(now())
  paidAt         DateTime?

  // Relations
  creator User @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@unique([contentType, contentId, creatorId])
  @@index([creatorId, calculatedAt])
  @@map("revenue_shares")
}

model TipTransaction {
  id          String   @id @default(cuid())
  senderId    String
  recipientId String
  amount      Decimal  @db.Decimal(19, 4) // In currency units
  currency    String // "sparkle", "premium"
  message     String?  @db.Text
  contentType String? // "post", "comment", "video"
  contentId   String?
  isAnonymous Boolean  @default(false)
  createdAt   DateTime @default(now())

  // Relations
  sender    User @relation("sentTips", fields: [senderId], references: [id], onDelete: Cascade)
  recipient User @relation("receivedTips", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([senderId])
  @@index([recipientId])
  @@index([contentType, contentId])
  @@map("tip_transactions")
}

model StoreItem {
  id                   String      @id @default(cuid())
  sku                  String      @unique
  name                 String
  description          String?     @db.Text
  shortDescription     String?
  category             String
  subcategory          String?
  itemType             String // "avatar", "badge", "theme", "reaction", etc.
  rarity               BadgeRarity @default(COMMON)
  priceSparkle         Decimal? @db.Decimal(19, 4)
  pricePremium         Decimal? @db.Decimal(19, 4)
  originalPriceSparkle Decimal? @db.Decimal(19, 4)
  originalPricePremium Decimal? @db.Decimal(19, 4)
  discountPercentage   Int         @default(0)
  previewUrl           String?
  thumbnailUrl         String?
  images               String[]
  data                 Json? // Item-specific data
  requirements         Json? // Level, achievement requirements
  limitedEdition       Boolean     @default(false)
  stockRemaining       Int?
  maxPerUser           Int?
  featured             Boolean     @default(false)
  new                  Boolean     @default(false)
  availableFrom        DateTime?
  availableUntil       DateTime?
  metadata             Json?
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt

  // Relations
  inventory UserInventory[]
  bundles   StoreBundle[]   @relation("BundleItems")

  @@index([category])
  @@index([featured])
  @@index([availableFrom, availableUntil])
  @@map("store_items")
}

model StoreBundle {
  id                 String      @id @default(cuid())
  name               String
  description        String?
  priceSparkle       Decimal? @db.Decimal(19, 4)
  pricePremium       Decimal? @db.Decimal(19, 4)
  discountPercentage Int         @default(0)
  items              StoreItem[] @relation("BundleItems")
  availableFrom      DateTime?
  availableUntil     DateTime?
  maxPurchases       Int?
  createdAt          DateTime    @default(now())

  @@index([availableFrom, availableUntil])
  @@map("store_bundles")
}

model UserInventory {
  id           String    @id @default(cuid())
  userId       String
  itemId       String
  quantity     Int       @default(1)
  equipped     Boolean   @default(false)
  equippedAt   DateTime?
  customData   Json? // User customizations
  acquiredFrom String // "purchase", "achievement", "gift", etc.
  acquiredAt   DateTime  @default(now())
  expiresAt    DateTime?
  tradeable    Boolean   @default(true)
  giftedBy     String?

  // Relations
  user User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  item StoreItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@index([userId, equipped])
  @@index([itemId])
  @@map("user_inventory")
}

model Trade {
  id              String      @id @default(cuid())
  initiatorId     String
  recipientId     String
  status          TradeStatus @default(PENDING)
  initiatorItems  Json // Array of {itemId, quantity}
  recipientItems  Json // Array of {itemId, quantity}
  initiatorPoints Int         @default(0)
  recipientPoints Int         @default(0)
  message         String?     @db.Text
  responseMessage String?     @db.Text
  tradeValue      Int         @default(0) // Estimated value
  escrowId        String? // For secure trading
  expiresAt       DateTime    @default(dbgenerated("(CURRENT_TIMESTAMP + interval '7 days')"))
  respondedAt     DateTime?
  completedAt     DateTime?
  cancelledAt     DateTime?
  cancelReason    String?
  version         Int         @default(0) // For optimistic locking
  deleted         Boolean     @default(false)
  deletedAt       DateTime?
  deletedBy       String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  initiator User @relation("tradeInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  recipient User @relation("tradeRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([initiatorId, status])
  @@index([recipientId, status])
  @@index([status])
  @@index([deleted])
  // NEW: Add index for active trades
  @@index([status, expiresAt])
  @@map("trades")
}

model Quest {
  id               String    @id @default(cuid())
  code             String    @unique
  name             String    @db.VarChar(255)
  description      String?   @db.Text
  shortDescription String?
  icon             String?
  bannerImage      String?
  type             QuestType
  category         String?
  difficulty       String? // "easy", "medium", "hard", "epic"
  requirements     Json // Quest completion criteria
  rewards          Json // Rewards specification
  xpReward         Int       @default(0)
  pointsReward     Int       @default(0)
  prerequisiteIds  String[] // Required quests
  levelRequired    Int       @default(1)
  cooldownHours    Int? // For repeatable quests
  maxCompletions   Int       @default(1)
  timeLimit        Int? // In minutes
  availableFrom    DateTime?
  availableUntil   DateTime?
  metadata         Json?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  userQuests UserQuest[]

  @@index([type])
  @@index([availableFrom, availableUntil])
  @@map("quests")
}

model UserQuest {
  id           String      @id @default(cuid())
  userId       String
  questId      String
  status       QuestStatus @default(AVAILABLE)
  progress     Json        @default("{}")
  currentStep  Int         @default(0)
  totalSteps   Int         @default(1)
  startedAt    DateTime    @default(now())
  completedAt  DateTime?
  claimedAt    DateTime?
  expiresAt    DateTime?
  attemptCount Int         @default(1)
  bestTime     Int? // In seconds
  metadata     Json?

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  quest Quest @relation(fields: [questId], references: [id], onDelete: Cascade)

  @@unique([userId, questId])
  @@index([userId, status])
  @@index([questId, status])
  @@map("user_quests")
}

model Leaderboard {
  id          String   @id @default(cuid())
  type        String // "xp", "sparkle", "posts", "achievements", etc.
  scope       String // "global", "regional", "group"
  scopeId     String? // Group ID, region code, etc.
  period      String // "daily", "weekly", "monthly", "alltime"
  periodStart DateTime
  periodEnd   DateTime
  data        Json // Sorted leaderboard data
  metadata    Json?
  processed   Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@unique([type, scope, scopeId, periodStart, periodEnd])
  @@index([type, periodEnd(sort: Desc)])
  @@index([processed])
  @@map("leaderboards")
}

model LeaderboardEntry {
  id        String   @id @default(cuid())
  userId    String
  type      String
  period    String
  rank      Int
  score     BigInt
  movement  Int      @default(0) // Rank change from previous period
  metadata  Json?
  createdAt DateTime @default(now())

  @@unique([userId, type, period])
  @@index([type, period, rank])
  @@index([userId])
  @@map("leaderboard_entries")
}

// =====================================================
// YOUTUBE INTEGRATION MODELS
// =====================================================

model YoutubeChannel {
  id                   String    @id @default(cuid())
  channelId            String    @unique
  userId               String?
  channelTitle         String?
  channelHandle        String?
  channelDescription   String?   @db.Text
  channelData          Json?
  thumbnailUrl         String?
  bannerUrl            String?
  subscriberCount      BigInt    @default(0)
  viewCount            BigInt    @default(0)
  videoCount           Int       @default(0)
  lastVideoId          String?
  lastVideoTitle       String?
  lastVideoPublishedAt DateTime?
  lastSyncedAt         DateTime?
  syncEnabled          Boolean   @default(true)
  featured             Boolean   @default(false)
  verified             Boolean   @default(false)
  metadata             Json?
  deleted              Boolean   @default(false)
  deletedAt            DateTime?
  deletedBy            String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Relations
  user   User?          @relation(fields: [userId], references: [id], onDelete: SetNull)
  videos YoutubeVideo[]

  @@index([userId])
  @@index([channelId])
  @@index([featured, deleted])
  @@map("youtube_channels")
}

model YoutubeVideo {
  id                String    @id @default(cuid())
  videoId           String    @unique
  channelId         String
  youtubeChannelId  String?
  title             String?   @db.VarChar(500)
  description       String?   @db.Text
  thumbnailUrl      String?
  thumbnailUrlHd    String?
  duration          Int? // In seconds
  durationFormatted String? // "HH:MM:SS"
  viewCount         BigInt    @default(0)
  likeCount         Int       @default(0)
  commentCount      Int       @default(0)
  tags              String[]
  categoryId        String?
  liveBroadcast     Boolean   @default(false)
  premiereDate      DateTime?
  publishedAt       DateTime?
  metadata          Json?
  lastSyncedAt      DateTime?
  createdAt         DateTime  @default(now())

  // Relations
  channel      YoutubeChannel? @relation(fields: [youtubeChannelId], references: [id], onDelete: SetNull)
  watchParties WatchParty[]
  clips        VideoClip[]
  analytics    VideoAnalytics?

  @@index([channelId])
  @@index([publishedAt(sort: Desc)])
  @@index([viewCount])
  @@map("youtube_videos")
}

model VideoAnalytics {
  id                  String   @id @default(cuid())
  videoId             String   @unique
  watchTime           BigInt   @default(0) // Total seconds watched
  avgWatchTime        Float    @default(0)
  completionRate      Float    @default(0)
  engagementRate      Float    @default(0)
  clipCount           Int      @default(0)
  shareCount          Int      @default(0)
  discussionCount     Int      @default(0)
  sentimentScore      Float? // -1 to 1
  topDiscussionTopics String[]
  peakViewers         Int      @default(0)
  updatedAt           DateTime @updatedAt

  // Relations
  video YoutubeVideo @relation(fields: [videoId], references: [videoId], onDelete: Cascade)

  @@index([videoId])
  @@map("video_analytics")
}

model WatchParty {
  id                  String    @id @default(cuid())
  hostId              String
  title               String    @db.VarChar(500)
  description         String?   @db.Text
  youtubeVideoId      String?
  youtubeVideoUrl     String?
  scheduledStart      DateTime
  actualStart         DateTime?
  endedAt             DateTime?
  maxParticipants     Int       @default(50)
  currentParticipants Int       @default(0)
  isPublic            Boolean   @default(true)
  requiresApproval    Boolean   @default(false)
  chatEnabled         Boolean   @default(true)
  syncPlayback        Boolean   @default(true)
  allowGuestChat      Boolean   @default(false)
  recordChat          Boolean   @default(true)
  tags                String[]
  customEmotes        Json?
  partyCode           String?   @unique
  cancelledAt         DateTime?
  cancelReason        String?
  metadata            Json?
  deleted             Boolean   @default(false)
  deletedAt           DateTime?
  deletedBy           String?
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  host         User                    @relation(fields: [hostId], references: [id], onDelete: Cascade)
  video        YoutubeVideo?           @relation(fields: [youtubeVideoId], references: [videoId], onDelete: SetNull)
  participants WatchPartyParticipant[]
  chat         WatchPartyChat[]

  @@index([hostId])
  @@index([scheduledStart])
  @@index([isPublic, scheduledStart])
  @@index([partyCode])
  @@index([deleted])
  @@map("watch_parties")
}

model WatchPartyParticipant {
  id               String    @id @default(cuid())
  partyId          String
  userId           String
  role             String    @default("viewer") // "host", "moderator", "viewer"
  joinedAt         DateTime  @default(now())
  leftAt           DateTime?
  isActive         Boolean   @default(true)
  playbackPosition Int       @default(0)
  isMuted          Boolean   @default(false)
  isBanned         Boolean   @default(false)
  bannedAt         DateTime?
  banReason        String?
  messageCount     Int       @default(0)
  reactionCount    Int       @default(0)

  // Relations
  party WatchParty @relation(fields: [partyId], references: [id], onDelete: Cascade)
  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([partyId, userId])
  @@index([partyId, isActive])
  @@index([userId])
  @@map("watch_party_participants")
}

// FIX: Ensure relation names are properly defined
model WatchPartyChat {
  id        String    @id @default(cuid())
  partyId   String
  userId    String
  message   String    @db.Text
  timestamp Int
  replyToId String?
  reactions Json?
  deleted   Boolean   @default(false)
  deletedAt DateTime?
  deletedBy String?
  createdAt DateTime  @default(now())

  // Relations - FIXED: Consistent relation naming
  party   WatchParty       @relation(fields: [partyId], references: [id], onDelete: Cascade)
  user    User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo WatchPartyChat?  @relation("WatchPartyChatReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies WatchPartyChat[] @relation("WatchPartyChatReplies")

  @@index([partyId, createdAt])
  @@index([userId])
  @@map("watch_party_chat")
}

model VideoClip {
  id             String   @id @default(cuid())
  youtubeVideoId String?
  creatorId      String
  title          String   @db.VarChar(500)
  description    String?  @db.Text
  startTime      Int // In seconds
  endTime        Int // In seconds
  duration       Int // Calculated: endTime - startTime
  thumbnailUrl   String?
  tags           String[]
  viewCount      Int      @default(0)
  likeCount      Int      @default(0)
  shareCount     Int      @default(0)
  featured       Boolean  @default(false)
  metadata       Json?
  createdAt      DateTime @default(now())

  // Relations
  video   YoutubeVideo? @relation(fields: [youtubeVideoId], references: [videoId], onDelete: SetNull)
  creator User          @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([youtubeVideoId])
  @@index([creatorId])
  @@index([viewCount])
  @@map("video_clips")
}

model Playlist {
  id              String   @id @default(cuid())
  title           String   @db.VarChar(500)
  slug            String   @unique @db.VarChar(255)
  description     String?  @db.Text
  ownerId         String
  isCollaborative Boolean  @default(false)
  collaboratorIds String[]
  isPublic        Boolean  @default(true)
  coverImage      String?
  tags            String[]
  viewCount       Int      @default(0)
  likeCount       Int      @default(0)
  followerCount   Int      @default(0)
  itemCount       Int      @default(0)
  totalDuration   Int      @default(0) // In seconds
  featured        Boolean  @default(false)
  metadata        Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  owner User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  items PlaylistItem[]

  @@index([ownerId])
  @@index([isPublic])
  @@index([slug])
  @@map("playlists")
}

model PlaylistItem {
  id             String   @id @default(cuid())
  playlistId     String
  youtubeVideoId String
  addedBy        String
  position       Int
  note           String?  @db.Text
  customTitle    String?
  startTime      Int? // Custom start time
  endTime        Int? // Custom end time
  addedAt        DateTime @default(now())

  // Relations
  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [addedBy], references: [id], onDelete: Cascade)

  @@unique([playlistId, position])
  @@index([playlistId])
  @@index([addedBy])
  @@map("playlist_items")
}

model YouTubeApiQuota {
  id             String   @id @default(cuid())
  date           DateTime @default(dbgenerated("CURRENT_DATE"))
  unitsUsed      Int      @default(0)
  quotaLimit     Int      @default(10000)
  readRequests   Int      @default(0)
  writeRequests  Int      @default(0)
  searchRequests Int      @default(0)
  resetAt        DateTime

  @@unique([date])
  @@index([date])
  @@map("youtube_api_quota")
}

// =====================================================
// SOCIAL FEATURES MODELS
// =====================================================

// =====================================================
// GROUP MODEL - JSON INDEX REQUIREMENTS
// =====================================================
// 
// JSON GIN INDEXES REQUIRED (via migration):
// - CREATE INDEX idx_group_guidelines ON groups USING GIN (guidelines);
// - CREATE INDEX idx_group_settings ON groups USING GIN (settings);
// - CREATE INDEX idx_group_emojis ON groups USING GIN (customEmojis);
// =====================================================
model Group {
  id               String          @id @default(cuid())
  name             String          @db.VarChar(255)
  slug             String          @unique @db.VarChar(255)
  description      String?         @db.Text
  shortDescription String?
  bannerImage      String?
  icon             String?
  coverImage       String?
  ownerId          String?
  ownerName        String?         // Preserved owner name for deleted users
  visibility       GroupVisibility @default(PUBLIC)
  joinApproval     Boolean         @default(false)
  // v4.1: Extracted frequently queried settings
  autoApproveMembers   Boolean         @default(false)
  allowGuestViewing    Boolean         @default(true)
  requirePostApproval  Boolean         @default(false)
  memberCount      Int             @default(1)
  postCount        Int             @default(0)
  onlineCount      Int             @default(0)
  rules            String?         @db.Text
  guidelines       Json?           // INDEX: GIN index recommended
  tags             String[]
  categories       String[]
  settings         Json            @default("{}") // INDEX: GIN index recommended
  features         String[] // Enabled features for the group
  customEmojis     Json?           // INDEX: GIN index recommended
  isOfficial       Boolean         @default(false)
  isVerified       Boolean         @default(false)
  isFeatured       Boolean         @default(false)
  metadata         Json?
  version          Int             @default(0) // For optimistic locking
  deleted          Boolean         @default(false)
  deletedAt        DateTime?
  deletedBy        String?
  createdAt        DateTime        @default(now())
  updatedAt        DateTime        @updatedAt

  // Relations - Updated to handle user deletion
  owner    User?          @relation("GroupOwner", fields: [ownerId], references: [id], onDelete: SetNull)
  members  GroupMember[]  @relation("GroupMembers")
  events   Event[]
  posts    GroupPost[]    @relation("GroupPosts")
  channels GroupChannel[]

  @@index([slug])
  @@index([ownerId])
  @@index([visibility, deleted])
  @@index([isFeatured, deleted])
  // v4.1: New indexes for extracted fields
  @@index([autoApproveMembers])
  @@index([requirePostApproval])
  @@map("groups")
}

model GroupMember {
  id            String          @id @default(cuid())
  groupId       String
  userId        String
  role          GroupMemberRole @default(MEMBER)
  permissions   String[]
  joinedAt      DateTime        @default(now())
  invitedBy     String?
  approvedBy    String?
  mutedUntil    DateTime?
  bannedUntil   DateTime?
  banReason     String?
  contribution  Int             @default(0) // Group-specific points
  lastActiveAt  DateTime        @default(now())
  notifications Boolean         @default(true)

  // Relations
  group Group @relation("GroupMembers", fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId, role])
  @@index([userId])
  @@map("group_members")
}

model GroupPost {
  id               String           @id @default(cuid())
  groupId          String
  authorId         String
  title            String?
  content          String           @db.Text
  isPinned         Boolean          @default(false)
  isAnnouncement   Boolean          @default(false)
  allowComments    Boolean          @default(true)
  viewCount        Int              @default(0)
  reactionCount    Int              @default(0)
  commentCount     Int              @default(0)
  moderationStatus ModerationStatus @default(AUTO_APPROVED)
  version          Int              @default(0)  // NEW: Add optimistic locking
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  group  Group @relation("GroupPosts", fields: [groupId], references: [id], onDelete: Cascade)
  author User  @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([groupId, isPinned, createdAt(sort: Desc)])
  @@index([authorId])
  @@map("group_posts")
}

model GroupChannel {
  id          String   @id @default(cuid())
  groupId     String
  name        String   @db.VarChar(255)
  description String?
  type        String // "text", "voice", "announcement"
  position    Int      @default(0)
  permissions Json?
  createdAt   DateTime @default(now())

  // Relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, name])
  @@index([groupId])
  @@map("group_channels")
}

// =====================================================
// EVENT MODEL - JSON INDEX REQUIREMENTS
// =====================================================
// 
// JSON GIN INDEXES REQUIRED (via migration):
// - CREATE INDEX idx_event_agenda ON events USING GIN (agenda);
// - CREATE INDEX idx_event_speakers ON events USING GIN (speakers);
// - CREATE INDEX idx_event_sponsors ON events USING GIN (sponsors);
// =====================================================
model Event {
  id               String      @id @default(cuid())
  title            String      @db.VarChar(500)
  slug             String      @unique @db.VarChar(255)
  description      String?     @db.Text
  shortDescription String?
  type             EventType
  status           EventStatus @default(SCHEDULED)
  hostId           String?
  hostName         String?     // Preserved host name for deleted users
  cohostIds        String[]
  groupId          String?
  locationName     String?
  locationUrl      String?
  locationAddress  String?
  locationCoords   Json? // {lat, lng}
  isVirtual        Boolean     @default(false)
  virtualPlatform  String? // "zoom", "discord", "youtube", etc.
  virtualLink      String?
  bannerImage      String?
  thumbnailImage   String?
  startTime        DateTime
  endTime          DateTime
  timezone         String      @default("UTC")
  recurrence       Json? // Recurrence rules
  // v4.1: Extracted recurrence fields
  recurrenceType   String? // "daily", "weekly", "monthly", "custom"
  recurrenceInterval Int? // Interval between recurrences
  recurrenceEndDate DateTime? // When recurrence ends
  maxAttendees     Int?
  currentAttendees Int         @default(0)
  minAttendees     Int?
  isPublic         Boolean     @default(true)
  requiresApproval Boolean     @default(false)
  requiresPayment  Boolean     @default(false)
  price            Decimal? @db.Decimal(19, 4)
  currency         String?
  tags             String[]
  categories       String[]
  agenda           Json?       // INDEX: GIN index recommended
  speakers         Json?       // INDEX: GIN index recommended
  sponsors         Json?       // INDEX: GIN index recommended
  streamUrl        String?
  recordingUrl     String?
  materials        Json? // Links to materials
  feedback         Json? // Post-event feedback settings
  remindersSent    String[] // Track which reminders have been sent
  metadata         Json?
  cancelledAt      DateTime?
  cancelReason     String?
  version          Int         @default(0) // For optimistic locking
  deleted          Boolean     @default(false)
  deletedAt        DateTime?
  deletedBy        String?
  createdAt        DateTime    @default(now())
  updatedAt        DateTime    @updatedAt

  // Relations - Updated to handle user deletion
  host      User?           @relation("EventHost", fields: [hostId], references: [id], onDelete: SetNull)
  group     Group?          @relation(fields: [groupId], references: [id], onDelete: SetNull)
  attendees EventAttendee[]

  @@index([hostId])
  @@index([groupId])
  @@index([startTime, isPublic])
  @@index([status, startTime])
  @@index([slug])
  @@index([deleted])
  // v4.1: New indexes for recurrence
  @@index([recurrenceType])
  @@map("events")
}

model EventAttendee {
  id            String    @id @default(cuid())
  eventId       String
  userId        String
  status        String    @default("INTERESTED") // "INTERESTED", "GOING", "NOT_GOING", "WAITLISTED"
  role          String    @default("ATTENDEE") // "ATTENDEE", "SPEAKER", "ORGANIZER", "VOLUNTEER"
  approved      Boolean   @default(true)
  approvedAt    DateTime?
  approvedBy    String?
  checkInTime   DateTime?
  checkInMethod String? // "manual", "qr", "auto"
  attended      Boolean   @default(false)
  rating        Int? // Post-event rating 1-5
  feedback      String?   @db.Text
  certificateId String? // For events that issue certificates
  notes         String?   @db.Text
  remindersSent Boolean   @default(false)
  createdAt     DateTime  @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId, status])
  @@index([userId])
  @@map("event_attendees")
}

// =====================================================
// MESSAGING MODELS - ENHANCED INDEXES
// =====================================================

model Conversation {
  id             String    @id @default(cuid())
  isGroup        Boolean   @default(false)
  title          String?
  description    String?
  icon           String?
  encryptedKey   String?   @db.Text
  lastMessageId  String?
  lastMessageAt  DateTime?
  messageCount   Int       @default(0)
  createdBy      String
  settings       Json      @default("{}")
  pinnedMessages String[]
  isArchived     Boolean   @default(false)
  archivedAt     DateTime?
  version        Int       @default(0) // v4.1: Added for optimistic locking
  deleted        Boolean   @default(false)
  deletedAt      DateTime?
  deletedBy      String?
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  creator      User                      @relation("ConversationCreator", fields: [createdBy], references: [id], onDelete: Cascade)
  participants ConversationParticipant[]
  messages     Message[]

  @@index([createdBy])
  @@index([lastMessageAt])
  @@index([deleted])
  // v4.1: New composite indexes
  @@index([isArchived, lastMessageAt(sort: Desc)])
  @@map("conversations")
}

model ConversationParticipant {
  id                 String    @id @default(cuid())
  conversationId     String
  userId             String
  nickname           String?
  role               String    @default("member") // "admin", "member"
  joinedAt           DateTime  @default(now())
  leftAt             DateTime?
  isActive           Boolean   @default(true)
  lastReadAt         DateTime?
  lastReadMessageId  String?
  unreadCount        Int       @default(0)
  notificationsMuted Boolean   @default(false)
  mutedUntil         DateTime?
  isPinned           Boolean   @default(false)
  customSettings     Json?

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId, isPinned])
  // v4.1: New composite index for unread messages
  @@index([userId, unreadCount, lastReadAt])
  // v4.3: Enhanced composite indexes
  @@index([userId, isPinned, lastReadAt(sort: Desc)]) // Pinned convos
  @@map("conversation_participants")
}

// =====================================================
// MESSAGE MODEL - QUERY OPTIMIZATION
// =====================================================
// 
// COMMON QUERIES:
// - Conversation messages: conversationId + createdAt
// - Undelivered messages: conversationId + status
// - User's sent messages: senderId + createdAt
// =====================================================
model Message {
  id               String        @id @default(cuid())
  conversationId   String
  senderId         String
  content          String?       @db.Text
  encryptedContent String?       @db.Text
  messageType      String        @default("TEXT") // "TEXT", "IMAGE", "VIDEO", "FILE", "AUDIO", "SYSTEM"
  attachments      Json? // Array of attachment objects
  mentions         String[] // User IDs mentioned
  replyToId        String?
  forwardedFrom    String?
  reactions        Json? // { "👍": ["userId1", "userId2"], ... }
  metadata         Json?
  edited           Boolean       @default(false)
  editedAt         DateTime?
  editHistory      Json[]
  deleted          Boolean       @default(false)
  deletedAt        DateTime?
  deletedFor       String[] // User IDs who deleted this message
  status           MessageStatus @default(SENT)
  deliveredAt      DateTime?
  errorMessage     String?
  version          Int           @default(0) // v4.1: Added for optimistic locking
  createdAt        DateTime      @default(now())

  // Relations
  conversation Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  replyTo      Message?      @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies      Message[]     @relation("MessageReplies")
  reads        MessageRead[]

  @@index([conversationId, createdAt(sort: Desc)])
  @@index([senderId])
  // v4.1: New composite index for status queries
  @@index([conversationId, status, createdAt])
  // v4.3: Additional indexes for common patterns
  @@index([conversationId, deleted, createdAt(sort: Desc)]) // Non-deleted messages
  @@index([senderId, createdAt(sort: Desc)]) // User's sent messages
  @@map("messages")
}

model MessageRead {
  messageId String
  userId    String
  readAt    DateTime @default(now())

  // Relations
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId])
  @@index([userId])
  @@map("message_reads")
}

// =====================================================
// REAL-TIME SUPPORT MODELS
// =====================================================

model WebsocketSession {
  id               String   @id @default(cuid())
  userId           String
  socketId         String   @unique
  ipAddress        String?
  userAgent        String?  @db.Text
  deviceType       String?
  location         String?
  connectedAt      DateTime @default(now())
  lastPingAt       DateTime @default(now())
  disconnectReason String?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([socketId])
  @@map("websocket_sessions")
}

model ChatRoom {
  id             String    @id @default(cuid())
  name           String    @db.VarChar(255)
  slug           String    @unique @db.VarChar(255)
  description    String?   @db.Text
  topic          String?
  tags           String[]
  isPublic       Boolean   @default(true)
  isModerated    Boolean   @default(false)
  isPersistent   Boolean   @default(true) // False for temporary rooms
  maxUsers       Int       @default(100)
  activeUsers    Int       @default(0)
  totalMessages  Int       @default(0)
  slowMode       Int       @default(0) // Seconds between messages
  customEmojis   Json?
  rules          String?   @db.Text
  welcomeMessage String?
  pinnedMessage  String?
  blockedWords   String[]
  createdBy      String
  moderatorIds   String[]
  expiresAt      DateTime? // For temporary rooms
  lastActiveAt   DateTime  @default(now())
  version        Int       @default(0) // v4.1: Added for optimistic locking
  createdAt      DateTime  @default(now())

  // Relations
  creator  User          @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  messages ChatMessage[]

  @@index([slug])
  @@index([isPublic])
  @@index([lastActiveAt])
  @@map("chat_rooms")
}

model ChatMessage {
  id            String    @id @default(cuid())
  roomId        String
  userId        String
  content       String    @db.Text
  mentions      String[]
  attachments   Json?
  replyToId     String?
  systemMessage Boolean   @default(false)
  highlighted   Boolean   @default(false)
  reactions     Json? // { "👍": 5, "❤️": 3 }
  edited        Boolean   @default(false)
  editedAt      DateTime?
  deleted       Boolean   @default(false)
  deletedAt     DateTime?
  deletedBy     String?
  flagged       Boolean   @default(false)
  flagReason    String?
  createdAt     DateTime  @default(now())

  // Relations
  room    ChatRoom      @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user    User          @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo ChatMessage?  @relation("ChatMessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies ChatMessage[] @relation("ChatMessageReplies")

  @@index([roomId, createdAt(sort: Desc)])
  @@index([userId])
  @@map("chat_messages")
}

model CollaborativeSpace {
  id               String   @id @default(cuid())
  type             String // "document", "whiteboard", "code", "canvas"
  title            String   @db.VarChar(500)
  description      String?  @db.Text
  ownerId          String
  content          Json?
  version          Int      @default(1)
  isPublic         Boolean  @default(false)
  isTemplate       Boolean  @default(false)
  allowAnonymous   Boolean  @default(false)
  maxCollaborators Int      @default(10)
  activeUsers      Int      @default(0)
  editPermission   String   @default("collaborators") // "owner", "collaborators", "anyone"
  viewPermission   String   @default("anyone") // "owner", "collaborators", "anyone"
  forkable         Boolean  @default(true)
  forkCount        Int      @default(0)
  parentId         String? // For forked spaces
  tags             String[]
  lastEditedAt     DateTime @default(now())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  owner         User                @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  collaborators SpaceCollaborator[]

  @@index([ownerId])
  @@index([type])
  @@index([isPublic])
  @@map("collaborative_spaces")
}

model SpaceCollaborator {
  id           String   @id @default(cuid())
  spaceId      String
  userId       String
  role         String   @default("editor") // "viewer", "editor", "admin"
  canEdit      Boolean  @default(true)
  canComment   Boolean  @default(true)
  canInvite    Boolean  @default(false)
  lastActiveAt DateTime @default(now())
  joinedAt     DateTime @default(now())
  invitedBy    String?

  // Relations
  space CollaborativeSpace @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  user  User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([spaceId, userId])
  @@index([spaceId])
  @@index([userId])
  @@map("space_collaborators")
}

model PresenceTracking {
  id           String   @id @default(cuid())
  userId       String
  location     String // "post:123", "room:abc", "space:xyz"
  locationType String // "post", "room", "space", "profile"
  deviceId     String?
  status       String   @default("active") // "active", "idle", "away"
  lastActiveAt DateTime @default(now())
  metadata     Json? // Additional context

  @@unique([userId, location])
  @@index([location])
  @@index([userId])
  @@map("presence_tracking")
}

// =====================================================
// ACTIVITY & ANALYTICS MODELS
// =====================================================

// =====================================================
// ACTIVITY STREAM - QUERY PATTERNS
// =====================================================
// 
// COMMON QUERIES:
// - User's activity feed: userId + createdAt
// - Entity activity: entityType + entityId
// - Public activities: visibility + createdAt
// =====================================================
model ActivityStream {
  id         String   @id @default(cuid())
  userId     String
  action     String // "post.created", "user.followed", "achievement.unlocked"
  entityType String // "post", "user", "comment", etc.
  entityId   String
  entityData Json? // Snapshot of entity at time of action
  metadata   Json?
  visibility String   @default("PUBLIC") // "PUBLIC", "FOLLOWERS", "PRIVATE"
  ipAddress  String?
  userAgent  String?  @db.Text
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([entityType, entityId])
  @@index([action])
  // v4.3: Additional indexes for feed queries
  @@index([visibility, createdAt(sort: Desc)]) // Public feed
  @@index([userId, visibility, createdAt(sort: Desc)]) // User's public activities
  @@map("activity_streams")
}

model UserActivity {
  id                   String   @id @default(cuid())
  userId               String   @unique
  date                 DateTime @default(dbgenerated("CURRENT_DATE"))
  loginCount           Int      @default(0)
  pageViews            Int      @default(0)
  postsCreated         Int      @default(0)
  postsViewed          Int      @default(0)
  commentsCreated      Int      @default(0)
  reactionsGiven       Int      @default(0)
  messagesSent         Int      @default(0)
  minutesActive        Int      @default(0)
  xpEarned             Int      @default(0)
  pointsEarned         Int      @default(0)
  achievementsUnlocked Int      @default(0)

  @@unique([userId, date])
  @@index([date])
  // v4.3: New index for analytics queries
  @@index([date, minutesActive(sort: Desc)]) // Most active users by date
  @@map("user_activity")
}

model ContentPerformance {
  id                String   @id @default(cuid())
  contentType       String // "post", "comment", "video"
  contentId         String
  date              DateTime @default(dbgenerated("CURRENT_DATE"))
  impressions       Int      @default(0)
  uniqueImpressions Int      @default(0)
  clicks            Int      @default(0)
  engagements       Int      @default(0)
  shares            Int      @default(0)
  avgTimeSpent      Float    @default(0)
  bounceRate        Float    @default(0)
  viralityScore     Float    @default(0)

  @@unique([contentType, contentId, date])
  @@index([contentType, date])
  @@index([viralityScore])
  @@map("content_performance")
}

// =====================================================
// CONTENT VARIATION MODELS
// =====================================================

model Poll {
  id              String    @id @default(cuid())
  postId          String    @unique
  question        String    @db.Text
  multipleChoice  Boolean   @default(false)
  anonymousVoting Boolean   @default(false)
  showResults     String    @default("after_vote") // "always", "after_vote", "after_close"
  requireComment  Boolean   @default(false)
  minChoices      Int       @default(1)
  maxChoices      Int       @default(1)
  closeAt         DateTime?
  finalResults    Json? // Cached final results
  version         Int       @default(0) // v4.1: Added for optimistic locking
  deleted         Boolean   @default(false)
  deletedAt       DateTime?
  deletedBy       String?
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  post    Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  options PollOption[]
  votes   PollVote[]

  @@index([postId])
  @@index([deleted])
  @@map("polls")
}

model PollOption {
  id           String  @id @default(cuid())
  pollId       String
  optionText   String  @db.Text
  description  String?
  imageUrl     String?
  displayOrder Int
  voteCount    Int     @default(0)
  percentage   Float   @default(0)
  metadata     Json?

  // Relations
  poll        Poll             @relation(fields: [pollId], references: [id], onDelete: Cascade)
  voteChoices PollVoteChoice[]

  @@index([pollId])
  @@map("poll_options")
}

model PollVote {
  id        String   @id @default(cuid())
  pollId    String
  userId    String
  comment   String?  @db.Text
  ipAddress String?
  metadata  Json?
  createdAt DateTime @default(now())

  // Relations
  poll    Poll             @relation(fields: [pollId], references: [id], onDelete: Cascade)
  user    User             @relation(fields: [userId], references: [id], onDelete: Cascade)
  choices PollVoteChoice[]

  @@unique([pollId, userId])
  @@index([pollId])
  @@index([userId])
  @@map("poll_votes")
}

model PollVoteChoice {
  id           String @id @default(cuid())
  pollVoteId   String
  pollOptionId String

  // Relations
  pollVote   PollVote   @relation(fields: [pollVoteId], references: [id], onDelete: Cascade)
  pollOption PollOption @relation(fields: [pollOptionId], references: [id], onDelete: Cascade)

  @@unique([pollVoteId, pollOptionId])
  @@index([pollVoteId])
  @@index([pollOptionId])
  @@map("poll_vote_choices")
}

model FanArtGallery {
  id                    String    @id @default(cuid())
  postId                String    @unique
  theme                 String?
  rules                 String?   @db.Text
  prizes                Json?
  submissionDeadline    DateTime?
  votingDeadline        DateTime?
  votingEnabled         Boolean   @default(true)
  publicVoting          Boolean   @default(true)
  maxSubmissionsPerUser Int       @default(3)
  requireApproval       Boolean   @default(false)
  allowNSFW             Boolean   @default(false)
  winnerCount           Int       @default(3)
  winnersAnnounced      Boolean   @default(false)
  metadata              Json?
  createdAt             DateTime  @default(now())

  // Relations
  post        Post               @relation(fields: [postId], references: [id], onDelete: Cascade)
  submissions FanArtSubmission[]

  @@index([postId])
  @@map("fan_art_galleries")
}

model FanArtSubmission {
  id               String           @id @default(cuid())
  galleryId        String
  artistId         String
  title            String           @db.VarChar(500)
  description      String?          @db.Text
  imageUrl         String
  thumbnailUrl     String?
  highResUrl       String?
  fileSize         Int?
  dimensions       Json? // {width, height}
  medium           String? // "digital", "traditional", "mixed"
  tools            String[] // Software/materials used
  timeSpent        Int? // In hours
  voteCount        Int              @default(0)
  avgRating        Float            @default(0)
  viewCount        Int              @default(0)
  featured         Boolean          @default(false)
  winner           Boolean          @default(false)
  winnerRank       Int?
  moderationStatus ModerationStatus @default(PENDING)
  moderationNotes  String?
  metadata         Json?
  createdAt        DateTime         @default(now())

  // Relations
  gallery FanArtGallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  artist  User          @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@index([galleryId])
  @@index([artistId])
  @@index([voteCount])
  @@map("fan_art_submissions")
}

// =====================================================
// AI & LEARNING MODELS
// =====================================================

model AiRecommendation {
  id                 String    @id @default(cuid())
  userId             String
  recommendationType String // "post", "user", "video", "creator"
  entityType         String // "post", "user", "video"
  entityId           String
  score              Float // AI confidence score
  reason             String? // Why this was recommended
  context            Json? // User context at time of recommendation
  clicked            Boolean   @default(false)
  clickedAt          DateTime?
  dismissed          Boolean   @default(false)
  expiresAt          DateTime
  createdAt          DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, entityType, entityId, recommendationType])
  @@index([userId, recommendationType])
  @@index([expiresAt])
  @@map("ai_recommendations")
}

model AiContentSuggestion {
  id             String   @id @default(cuid())
  userId         String
  suggestionType String // "title", "hashtag", "content", "image"
  content        String   @db.Text
  context        Json? // Original content context
  used           Boolean  @default(false)
  usedContent    String? // What user actually used
  feedback       Int? // 1-5 rating from user
  createdAt      DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, suggestionType])
  @@map("ai_content_suggestions")
}

model UserAiPreference {
  id                 String   @id @default(cuid())
  userId             String   @unique
  contentPreferences Json // Preferred content types
  writingStyle       Json? // User's writing style data
  learningOptedOut   Boolean  @default(false)
  lastUpdated        DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_ai_preferences")
}

model AiAssistantConversation {
  id         String   @id @default(cuid())
  userId     String
  sessionId  String   @unique
  messages   Json[] // Array of {role, content, timestamp}
  context    Json? // Conversation context
  model      String   @default("gpt-4")
  tokensUsed Int      @default(0)
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, updatedAt])
  @@map("ai_assistant_conversations")
}

// =====================================================
// MODERATION & SAFETY MODELS
// =====================================================

model Report {
  id                String           @id @default(cuid())
  reporterId        String
  reportedUserId    String?
  reportedPostId    String?
  reportedCommentId String?
  reason          ReportReason
  subreason       String?
  description     String?          @db.Text
  evidence        Json? // Screenshots, links, etc.
  status          ModerationStatus @default(PENDING)
  priority        Int              @default(0) // 0=low, 1=normal, 2=high, 3=urgent
  assignedTo      String?
  resolvedBy      String?
  resolvedAt      DateTime?
  resolution      String? // "warning", "ban", "no_action", etc.
  resolutionNote  String?          @db.Text
  appealable      Boolean          @default(true)
  entityType      String // "user", "post", "comment", etc.
  metadata        Json?
  deleted         Boolean          @default(false)
  deletedAt       DateTime?
  deletedBy       String?
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt

  // Relations - FIXED: Added missing reportedUser relation
  reporter     User     @relation("reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  reportedUser User?    @relation("reportedUser", fields: [reportedUserId], references: [id], onDelete: SetNull)  // NEW
  resolver     User?    @relation("resolver", fields: [resolvedBy], references: [id], onDelete: SetNull)
  post         Post?    @relation("reportedPost", fields: [reportedPostId], references: [id], onDelete: Cascade)
  comment      Comment? @relation("reportedComment", fields: [reportedCommentId], references: [id], onDelete: Cascade)

  @@index([status, priority])
  @@index([entityType])
  @@index([reporterId])
  @@index([reportedUserId])
  @@index([reportedPostId])
  @@index([reportedCommentId])
  @@index([deleted])
  @@map("reports")
}

model AiModerationQueue {
  id                  String    @id @default(cuid())
  entityType          String // "post", "comment", "message", "profile"
  entityId            String
  content             String?   @db.Text
  contentHash         String? // For duplicate detection
  aiProvider          String    @default("openai") // "openai", "perspective", "custom"
  aiScore             Float? // 0-1 probability of violation
  aiCategories        Json? // Detected categories with scores
  aiReasons           Json? // Detailed reasons
  confidence          Float? // AI confidence level
  humanReviewRequired Boolean   @default(false)
  autoActionTaken     String? // "blocked", "shadow_banned", "flagged"
  reviewPriority      Int       @default(0)
  reviewedBy          String?
  reviewDecision      String? // "approve", "reject", "escalate"
  reviewNotes         String?   @db.Text
  falsePositive       Boolean? // For AI training
  processingTime      Int? // In milliseconds
  createdAt           DateTime  @default(now())
  reviewedAt          DateTime?

  // Relations
  reviewer User? @relation("moderationReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)
  post     Post? @relation("moderatedPost", fields: [entityId], references: [id], onDelete: Cascade)

  @@index([humanReviewRequired, reviewPriority, createdAt])
  @@index([entityType, entityId])
  @@index([aiScore])
  @@map("ai_moderation_queue")
}

model ModerationAction {
  id              String    @id @default(cuid())
  moderatorId     String
  targetUserId    String?
  targetContentId String?
  targetType      String // "user", "post", "comment", etc.
  action          String // "warn", "mute", "ban", "delete", etc.
  duration        Int? // In hours
  reason          String
  details         String?   @db.Text
  evidence        Json?
  automated       Boolean   @default(false)
  reversedBy      String?
  reversedAt      DateTime?
  reverseReason   String?
  expiresAt       DateTime?
  createdAt       DateTime  @default(now())

  @@index([targetUserId])
  @@index([targetType, targetContentId])
  @@index([moderatorId])
  @@index([action])
  @@map("moderation_actions")
}

model ContentFilter {
  id         String    @id @default(cuid())
  filterType String // "keyword", "regex", "ai_category"
  pattern    String
  action     String // "block", "flag", "shadow_ban"
  severity   Int       @default(1) // 1-5
  category   String? // "spam", "hate", "nsfw", etc.
  isActive   Boolean   @default(true)
  hitCount   Int       @default(0)
  lastHitAt  DateTime?
  createdBy  String
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  @@index([filterType, isActive])
  @@index([pattern])
  @@map("content_filters")
}

// =====================================================
// ADDITIONAL SUPPORT MODELS
// =====================================================

model MediaFile {
  id              String    @id @default(cuid())
  userId          String
  fileType        String // "image", "video", "audio", "document"
  fileSize        BigInt
  mimeType        String?
  originalName    String?
  storagePath     String
  cdnUrl          String?
  thumbnailUrl    String?
  blurhash        String? // For image placeholders
  duration        Int? // For video/audio in seconds
  dimensions      Json? // {width, height} for images/videos
  metadata        Json? // EXIF data, video metadata, etc.
  processedAt     DateTime?
  processingError String?
  isPublic        Boolean   @default(true)
  accessCount     Int       @default(0)
  lastAccessedAt  DateTime?
  createdAt       DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([fileType])
  @@index([createdAt])
  // v4.3: Added missing index
  @@index([userId, fileType, createdAt(sort: Desc)]) // User's files by type
  @@map("media_files")
}

model Experiment {
  id                String    @id @default(cuid())
  name              String    @unique @db.VarChar(255)
  description       String?   @db.Text
  hypothesis        String?   @db.Text
  variants          Json // Array of variant configurations
  control           String // Control variant name
  metrics           Json // Metrics to track
  targetingRules    Json? // User targeting criteria
  trafficPercentage Int       @default(100)
  status            String    @default("DRAFT") // "DRAFT", "RUNNING", "PAUSED", "COMPLETED"
  results           Json? // Experiment results
  winner            String? // Winning variant
  startedAt         DateTime?
  endedAt           DateTime?
  createdBy         String
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  assignments ExperimentAssignment[]

  @@index([status])
  @@index([startedAt, endedAt])
  @@map("experiments")
}

model ExperimentAssignment {
  id             String    @id @default(cuid())
  experimentId   String
  userId         String
  variant        String
  converted      Boolean   @default(false)
  conversionData Json?
  assignedAt     DateTime  @default(now())
  convertedAt    DateTime?

  // Relations
  experiment Experiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([experimentId, userId])
  @@index([experimentId, variant])
  @@index([userId])
  @@map("experiment_assignments")
}

model FeatureFlag {
  id                String   @id @default(cuid())
  flag              String   @unique
  name              String   @db.VarChar(255)
  description       String?  @db.Text
  enabled           Boolean  @default(false)
  rolloutPercentage Int      @default(0)
  enabledForUsers   String[] // Specific user IDs
  enabledForRoles   String[] // User roles
  conditions        Json? // Complex targeting rules
  metadata          Json?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([flag])
  @@map("feature_flags")
}

model SiteSetting {
  key         String   @id
  value       Json
  type        String // "string", "number", "boolean", "json"
  category    String?
  description String?  @db.Text
  isPublic    Boolean  @default(false) // Visible to non-admins
  isEditable  Boolean  @default(true)
  validation  Json? // Validation rules
  updatedBy   String?
  updatedAt   DateTime @default(now())

  // Relations
  updater User? @relation(fields: [updatedBy], references: [id], onDelete: SetNull)

  @@index([category])
  @@map("site_settings")
}

model AuditLog {
  id           String      @id @default(cuid())
  userId       String?
  action       AuditAction
  entityType   String
  entityId     String
  entityData   Json? // Snapshot before change
  changedData  Json? // What changed
  reason       String?
  ipAddress    String?
  userAgent    String?     @db.Text
  sessionId    String?
  requestId    String? // For request tracing
  duration     Int? // Operation duration in ms
  errorMessage String?
  metadata     Json?
  createdAt    DateTime    @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

model AnalyticsEvent {
  id         String   @id @default(cuid())
  eventName  String
  eventType  String // "pageview", "click", "custom"
  userId     String?
  sessionId  String?
  properties Json?
  context    Json? // Device, browser, location info
  timestamp  DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([eventName, timestamp(sort: Desc)])
  @@index([userId])
  @@index([sessionId])
  @@index([timestamp])
  @@map("analytics_events")
}

model SearchIndex {
  id             String   @id @default(cuid())
  entityType     String // "post", "user", "comment", etc.
  entityId       String
  searchableText String   @db.Text
  title          String?
  description    String?
  tags           String[]
  boost          Float    @default(1) // Search ranking boost
  locale         String   @default("en")
  isPublic       Boolean  @default(true)
  lastIndexedAt  DateTime @default(now())
  metadata       Json?

  @@unique([entityType, entityId])
  @@index([entityType])
  // Note: Full-text search for PostgreSQL must be implemented via raw SQL migrations.
  // Example: CREATE INDEX "SearchIndex_searchableText_idx" ON "search_index" USING GIN (to_tsvector('english', "searchableText"));
  @@map("search_index")
}

model CacheEntry {
  key            String    @id
  value          Json
  type           CacheType
  tags           String[]
  expiresAt      DateTime
  accessCount    Int       @default(0)
  lastAccessedAt DateTime  @default(now())
  createdAt      DateTime  @default(now())

  @@index([type])
  @@index([expiresAt])
  @@index([tags])
  @@map("cache_entries")
}

model SystemHealth {
  id           String   @id @default(cuid())
  service      String // "api", "websocket", "worker", etc.
  status       String // "healthy", "degraded", "down"
  responseTime Float? // In ms
  errorRate    Float? // Percentage
  throughput   Float? // Requests per second
  cpuUsage     Float?
  memoryUsage  Float?
  diskUsage    Float?
  activeUsers  Int?
  queueDepth   Int?
  metadata     Json?
  checkedAt    DateTime @default(now())

  @@index([service, checkedAt])
  @@map("system_health")
}

model RateLimitTracker {
  id          String   @id @default(cuid())
  identifier  String // IP, userId, apiKey
  endpoint    String
  windowStart DateTime
  requests    Int      @default(1)
  blocked     Boolean  @default(false)

  @@unique([identifier, endpoint, windowStart])
  @@index([identifier])
  @@index([windowStart])
  @@map("rate_limit_tracker")
}

model EncryptionKey {
  id          String   @id @default(cuid())
  keyName     String   @unique
  keyVersion  Int      @default(1)
  algorithm   String   @default("AES-256-GCM")
  createdAt   DateTime @default(now())
  rotatedAt   DateTime?
  expiresAt   DateTime?
  isActive    Boolean  @default(true)
  
  @@index([keyName, isActive])
  @@map("encryption_keys")
}

model DataRetentionPolicy {
  id              String   @id @default(cuid())
  entityType      String   @unique // "user", "post", "message", etc.
  retentionDays   Int      // Days to retain after soft delete
  anonymizeDays   Int?     // Days until PII anonymization
  hardDeleteDays  Int      // Days until permanent deletion
  isActive        Boolean  @default(true)
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@map("data_retention_policies")
}

// =====================================================
// v4.3 MIGRATION NOTES
// =====================================================
// 
// Version 4.3 introduces the following performance optimizations:
// 
// 1. Enhanced User Model Documentation:
//    - Added comprehensive query complexity warnings
//    - Provided specific query pattern examples
//    - Documented relation loading strategies
//    - Added common query pattern documentation
// 
// 2. Strategic Composite Indexes Added:
//    - User: role+verified+createdAt for creator discovery
//    - User: deleted+status+lastSeenAt+onlineStatus for active users
//    - Post: authorId+isDraft+createdAt for author's drafts
//    - Post: scheduledPublishAt+contentStatus for publishing queue
//    - Post: contentType+moderationStatus+createdAt for moderation
//    - Comment: postId+parentId+deleted+createdAt for thread queries
//    - Comment: postId+pinned+createdAt for pinned comments
//    - Notification: userId+priority+read+createdAt for priority unread
//    - Notification: userId+type+createdAt for type-specific queries
//    - ConversationParticipant: userId+isPinned+lastReadAt for pinned convos
//    - Message: conversationId+deleted+createdAt for non-deleted messages
//    - Message: senderId+createdAt for user's sent messages
//    - ActivityStream: visibility+createdAt for public feed
//    - ActivityStream: userId+visibility+createdAt for user's public activities
//    - UserActivity: date+minutesActive for most active users
//    - MediaFile: userId+fileType+createdAt for user's files by type
//    - PostRevision: postId index added (was missing)
// 
// 3. JSON Field Performance Documentation:
//    - Documented GIN index requirements for all JSON fields
//    - Added specific path index examples
//    - Provided migration SQL examples
//    - Identified high-impact JSON fields
// 
// 4. Query Optimization Documentation:
//    - Added QUERY COMPLEXITY indicators for critical models
//    - Documented COMMON QUERIES patterns
//    - Provided performance notes and warnings
//    - Added best practice examples
// 
// =====================================================
// DATABASE IMPLEMENTATION NOTES
// =====================================================
// 
// The following must be implemented via raw SQL migrations:
// 
// 1. JSON GIN Indexes (CRITICAL for v4.3):
//    ```sql
//    -- Profile JSON indexes
//    CREATE INDEX idx_profile_theme ON profiles USING GIN (themePreference);
//    CREATE INDEX idx_profile_notifications ON profiles USING GIN (notificationSettings);
//    CREATE INDEX idx_profile_privacy ON profiles USING GIN (privacySettings);
//    CREATE INDEX idx_profile_social ON profiles USING GIN (socialLinks);
//    
//    -- Post JSON indexes
//    CREATE INDEX idx_post_content ON posts USING GIN (content);
//    CREATE INDEX idx_post_youtube_data ON posts USING GIN (youtubeVideoData);
//    CREATE INDEX idx_post_sponsor ON posts USING GIN (sponsorInfo);
//    CREATE INDEX idx_post_content_type ON posts ((content->>'type'));
//    CREATE INDEX idx_post_content_blocks ON posts ((content->'blocks'));
//    
//    -- Group JSON indexes
//    CREATE INDEX idx_group_guidelines ON groups USING GIN (guidelines);
//    CREATE INDEX idx_group_settings ON groups USING GIN (settings);
//    CREATE INDEX idx_group_emojis ON groups USING GIN (customEmojis);
//    
//    -- Event JSON indexes
//    CREATE INDEX idx_event_agenda ON events USING GIN (agenda);
//    CREATE INDEX idx_event_speakers ON events USING GIN (speakers);
//    CREATE INDEX idx_event_sponsors ON events USING GIN (sponsors);
//    ```
// 
// 2. Database Views for Performance:
//    - trending_posts (materialized view) - refresh hourly
//    - top_creators (materialized view) - refresh daily
//    - active_groups (materialized view) - refresh every 6 hours
//    - user_reputation_scores (view) - real-time calculation
//
// 3. Database Functions:
//    - calculate_user_level(experience INT)
//    - calculate_engagement_rate(post_id UUID)
//    - update_post_stats(post_id UUID)
//    - calculate_reputation_score(user_id UUID)
//
// 4. Database Triggers:
//    - Auto-update timestamps
//    - Update denormalized counts
//    - Level progression checks
//    - Achievement progress tracking
//
// 5. Performance Monitoring:
//    - Enable pg_stat_statements extension
//    - Monitor slow query logs
//    - Set up query performance alerts
//    - Track index usage statistics
//
// 6. Partitioning Strategy:
//    - Time-based partitioning for analytics_events (by month)
//    - Time-based partitioning for activity_streams (by month)
//    - Time-based partitioning for audit_logs (by quarter)
//    - Time-based partitioning for notifications (by month, archive after 6 months)
//
// 7. Database Extensions Required:
//    - pg_trgm for fuzzy text search
//    - pgcrypto for encryption
//    - uuid-ossp for UUID generation (if not using default)
//    - pg_stat_statements for query monitoring
//
// 8. Full-text Search Implementation:
//    ```sql
//    -- Posts full-text search
//    ALTER TABLE posts ADD COLUMN search_vector tsvector;
//    CREATE INDEX idx_post_search ON posts USING GIN (search_vector);
//    
//    -- Update trigger for search vector
//    CREATE OR REPLACE FUNCTION update_post_search_vector() RETURNS trigger AS $$
//    BEGIN
//      NEW.search_vector := 
//        setweight(to_tsvector('english', COALESCE(NEW.title, '')), 'A') ||
//        setweight(to_tsvector('english', COALESCE(NEW.excerpt, '')), 'B') ||
//        setweight(to_tsvector('english', COALESCE(NEW.content::text, '')), 'C');
//      RETURN NEW;
//    END;
//    $$ LANGUAGE plpgsql;
//    
//    CREATE TRIGGER update_post_search_vector_trigger
//    BEFORE INSERT OR UPDATE ON posts
//    FOR EACH ROW EXECUTE FUNCTION update_post_search_vector();
//    ```
//
// 9. Query Optimization Recommendations:
//    - Use EXPLAIN ANALYZE on all complex queries
//    - Monitor pg_stat_user_indexes for unused indexes
//    - Consider query result caching for hot paths
//    - Implement read replicas for analytics queries
//    - Use connection pooling (recommended: PgBouncer)
//
// 10. v4.3 Specific Performance Gains:
//     - User model queries: Expected 40-60% improvement with proper select/include
//     - Post feed queries: Expected 30-50% improvement with new composite indexes
//     - Message queries: Expected 25-40% improvement with enhanced indexes
//     - JSON field queries: 10x+ improvement with GIN indexes (must implement)
//
// These optimizations are critical for scaling beyond 100K active users.
