// =====================================================
// Sparkle Universe Complete Prisma Schema
// Version 3.0 - Enhanced Performance & Feature Complete
// =====================================================

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["jsonProtocol", "fullTextSearch", "fullTextIndex", "postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  extensions = [pgcrypto, pg_trgm, uuid_ossp]
}

// =====================================================
// ENUMS
// =====================================================

enum UserRole {
  USER
  MODERATOR
  ADMIN
  CREATOR
  VERIFIED_CREATOR
  SYSTEM
}

enum UserStatus {
  PENDING_VERIFICATION
  ACTIVE
  SUSPENDED
  BANNED
  DELETED
}

enum NotificationType {
  POST_LIKED
  POST_COMMENTED
  COMMENT_LIKED
  USER_FOLLOWED
  ACHIEVEMENT_UNLOCKED
  LEVEL_UP
  MENTION
  SYSTEM
  GROUP_INVITE
  GROUP_POST
  EVENT_REMINDER
  WATCH_PARTY_INVITE
  DIRECT_MESSAGE
  YOUTUBE_PREMIERE
  QUEST_COMPLETE
  TRADE_REQUEST
  CONTENT_FEATURED
  MILESTONE_REACHED
}

enum ReactionType {
  LIKE
  LOVE
  FIRE
  SPARKLE
  MIND_BLOWN
  LAUGH
  CRY
  ANGRY
  CUSTOM
}

enum ReportReason {
  SPAM
  INAPPROPRIATE
  HARASSMENT
  MISINFORMATION
  COPYRIGHT
  NSFW
  HATE_SPEECH
  SELF_HARM
  OTHER
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
  ESCALATED
  AUTO_APPROVED
  SHADOW_BANNED
  UNDER_REVIEW
}

enum ContentType {
  BLOG
  LIVE_BLOG
  POLL
  VIDEO_REVIEW
  FAN_ART
  THEORY_THREAD
  SERIES
  TUTORIAL
  NEWS
}

enum ContentStatus {
  DRAFT
  SCHEDULED
  PUBLISHED
  ARCHIVED
  DELETED
}

enum BadgeRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
  LIMITED_EDITION
  SEASONAL
}

enum QuestType {
  DAILY
  WEEKLY
  MONTHLY
  SPECIAL
  ACHIEVEMENT
  SEASONAL
  COMMUNITY
  CREATOR
}

enum QuestStatus {
  AVAILABLE
  IN_PROGRESS
  COMPLETED
  CLAIMED
  EXPIRED
  LOCKED
}

enum TradeStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
  EXPIRED
  COMPLETED
  DISPUTED
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
  DELETED
}

enum EventType {
  WATCH_PARTY
  COMMUNITY_MEETUP
  CONTEST
  PREMIERE
  AMA
  SPECIAL
  TOURNAMENT
  WORKSHOP
}

enum EventStatus {
  DRAFT
  SCHEDULED
  LIVE
  ENDED
  CANCELLED
}

enum GroupVisibility {
  PUBLIC
  PRIVATE
  INVITE_ONLY
  HIDDEN
}

enum GroupMemberRole {
  MEMBER
  MODERATOR
  ADMIN
  OWNER
}

enum CacheType {
  USER_PROFILE
  POST_CONTENT
  FEED
  TRENDING
  LEADERBOARD
  STATS
}

enum AuditAction {
  CREATE
  UPDATE
  DELETE
  LOGIN
  LOGOUT
  PERMISSION_CHANGE
  MODERATION_ACTION
  SYSTEM_ACTION
}

enum PaymentStatus {
  PENDING
  PROCESSING
  COMPLETED
  FAILED
  REFUNDED
  CANCELLED
}

enum SubscriptionTier {
  FREE
  SPARKLE_FAN
  SPARKLE_CREATOR
  SPARKLE_LEGEND
}

// =====================================================
// CORE MODELS
// =====================================================

model User {
  id                    String               @id @default(cuid())
  email                 String               @unique
  username              String               @unique
  hashedPassword        String?
  emailVerified         DateTime?
  phoneNumber           String?
  phoneVerified         DateTime?
  image                 String?
  bio                   String?              @db.Text
  role                  UserRole             @default(USER)
  status                UserStatus           @default(PENDING_VERIFICATION)
  verified              Boolean              @default(false)
  verifiedAt            DateTime?
  banned                Boolean              @default(false)
  banReason             String?
  banExpiresAt          DateTime?
  experience            Int                  @default(0)
  level                 Int                  @default(1)
  sparklePoints         Int                  @default(0)
  premiumPoints         Int                  @default(0)
  reputationScore       Int                  @default(0)
  lastSeenAt            DateTime?
  onlineStatus          Boolean              @default(false)
  twoFactorEnabled      Boolean              @default(false)
  twoFactorSecret       String?
  preferredLanguage     String               @default("en")
  timezone              String               @default("UTC")
  version               Int                  @default(0) // For optimistic locking
  createdAt             DateTime             @default(now())
  updatedAt             DateTime             @updatedAt
  deletedAt             DateTime?

  // Relations
  accounts              Account[]
  sessions              Session[]
  profile               Profile?
  stats                 UserStats?
  balance               UserBalance?
  subscription          UserSubscription?
  posts                 Post[]
  comments              Comment[]
  reactions             Reaction[]
  following             Follow[]             @relation("follower")
  followers             Follow[]             @relation("following")
  blockedUsers          Block[]              @relation("blocker")
  blockedBy             Block[]              @relation("blocked")
  achievements          UserAchievement[]
  notifications         Notification[]       @relation("notificationUser")
  notificationsSent     Notification[]       @relation("notificationActor")
  notificationPrefs     NotificationPreference?
  xpLogs                XpLog[]
  currencyTransactions  CurrencyTransaction[]
  inventory             UserInventory[]
  tradesInitiated       Trade[]              @relation("tradeInitiator")
  tradesReceived        Trade[]              @relation("tradeRecipient")
  questProgress         UserQuest[]
  youtubeChannels       YoutubeChannel[]
  hostedWatchParties    WatchParty[]
  watchPartyParticipants WatchPartyParticipant[]
  videoClips            VideoClip[]
  playlists             Playlist[]
  playlistItems         PlaylistItem[]
  groupsOwned           Group[]
  groupMemberships      GroupMember[]
  eventsHosted          Event[]
  eventAttendances      EventAttendee[]
  conversationsCreated  Conversation[]
  conversationParticipants ConversationParticipant[]
  messages              Message[]
  messageReads          MessageRead[]
  websocketSessions     WebsocketSession[]
  chatRoomsCreated      ChatRoom[]
  chatMessages          ChatMessage[]
  collaborativeSpacesOwned CollaborativeSpace[]
  spaceCollaborations   SpaceCollaborator[]
  activityStreams       ActivityStream[]
  fanArtSubmissions     FanArtSubmission[]
  mediaFiles            MediaFile[]
  experimentAssignments ExperimentAssignment[]
  moderationReviews     AiModerationQueue[]   @relation("moderationReviewer")
  reports               Report[]              @relation("reporter")
  reportResolutions     Report[]              @relation("resolver")
  siteSettingUpdates    SiteSetting[]
  postSeries            PostSeries[]
  auditLogs             AuditLog[]
  apiKeys               ApiKey[]
  webhooks              Webhook[]
  contentRevisions      PostRevision[]
  searchHistory         SearchHistory[]
  viewHistory           ViewHistory[]
  loginHistory          LoginHistory[]
  securityAlerts        SecurityAlert[]
  referralCodeUsed      Referral?            @relation("referredUser")
  referralsMade         Referral[]           @relation("referrer")

  @@index([email])
  @@index([username])
  @@index([role])
  @@index([level])
  @@index([onlineStatus])
  @@index([sparklePoints])
  @@index([status])
  @@index([createdAt])
  @@index([lastSeenAt])
  @@index([deletedAt])
  @@map("users")
}

model UserStats {
  id                  String    @id @default(cuid())
  userId              String    @unique
  totalPosts          Int       @default(0)
  totalComments       Int       @default(0)
  totalLikesReceived  Int       @default(0)
  totalLikesGiven     Int       @default(0)
  totalViews          Int       @default(0)
  totalFollowers      Int       @default(0)
  totalFollowing      Int       @default(0)
  totalWatchTime      BigInt    @default(0) // In seconds
  streakDays          Int       @default(0)
  longestStreak       Int       @default(0)
  lastActivityAt      DateTime?
  profileViews        Int       @default(0)
  engagementRate      Float     @default(0)
  contentQualityScore Float     @default(0)
  updatedAt           DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([totalFollowers])
  @@index([engagementRate])
  @@map("user_stats")
}

model UserBalance {
  id                String   @id @default(cuid())
  userId            String   @unique
  sparklePoints     Int      @default(0)
  premiumPoints     Int      @default(0)
  frozenPoints      Int      @default(0) // Points in pending trades
  lifetimeEarned    Int      @default(0)
  lifetimeSpent     Int      @default(0)
  version           Int      @default(0) // For optimistic locking
  lastTransactionAt DateTime?
  updatedAt         DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("user_balances")
}

model UserSubscription {
  id                String           @id @default(cuid())
  userId            String           @unique
  tier              SubscriptionTier @default(FREE)
  status            PaymentStatus    @default(PENDING)
  startDate         DateTime         @default(now())
  endDate           DateTime?
  cancelledAt       DateTime?
  paymentMethod     String?
  stripeCustomerId  String?
  stripeSubId       String?
  autoRenew         Boolean          @default(true)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([status])
  @@index([endDate])
  @@map("user_subscriptions")
}

model Profile {
  id                  String    @id @default(cuid())
  userId              String    @unique
  displayName         String?
  location            String?
  website             String?
  twitterUsername     String?
  instagramUsername   String?
  tiktokUsername      String?
  discordUsername     String?
  youtubeChannelId    String?
  youtubeChannelUrl   String?
  youtubeChannelData  Json?
  bannerImage         String?
  themePreference     Json?
  notificationSettings Json     @default("{}")
  privacySettings     Json     @default("{}")
  featuredBadges      String[]
  showcasedPosts      String[]
  customCss           String?   @db.Text
  customHtml          String?   @db.Text
  socialLinks         Json?
  interests           String[]
  skills              String[]
  pronouns            String?
  birthdate           DateTime?
  joinedCommunityAt   DateTime  @default(now())
  profileCompleted    Boolean   @default(false)
  profileCompleteness Int       @default(0)
  createdAt           DateTime  @default(now())
  updatedAt           DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([youtubeChannelId])
  @@index([profileCompleted])
  @@map("profiles")
}

model Account {
  id                String    @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refreshToken      String?   @db.Text
  accessToken       String?   @db.Text
  expiresAt         BigInt?
  tokenType         String?
  scope             String?
  idToken           String?   @db.Text
  sessionState      String?
  oauthTokenSecret  String?
  oauthToken        String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
  @@map("accounts")
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  ipAddress    String?
  userAgent    String?  @db.Text
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sessionToken])
  @@index([expires])
  @@map("sessions")
}

model LoginHistory {
  id         String   @id @default(cuid())
  userId     String
  ipAddress  String
  userAgent  String   @db.Text
  location   String?
  success    Boolean
  reason     String?
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@map("login_history")
}

model SecurityAlert {
  id          String   @id @default(cuid())
  userId      String
  type        String
  severity    String
  title       String
  description String   @db.Text
  resolved    Boolean  @default(false)
  resolvedAt  DateTime?
  createdAt   DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, resolved])
  @@index([severity])
  @@map("security_alerts")
}

model ApiKey {
  id          String    @id @default(cuid())
  userId      String
  name        String
  key         String    @unique
  permissions String[]
  expiresAt   DateTime?
  lastUsedAt  DateTime?
  createdAt   DateTime  @default(now())
  revokedAt   DateTime?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([key])
  @@map("api_keys")
}

model Webhook {
  id           String   @id @default(cuid())
  userId       String
  name         String
  url          String
  secret       String
  events       String[]
  active       Boolean  @default(true)
  failureCount Int      @default(0)
  lastTriggered DateTime?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([active])
  @@map("webhooks")
}

model Block {
  id         String   @id @default(cuid())
  blockerId  String
  blockedId  String
  reason     String?
  createdAt  DateTime @default(now())

  // Relations
  blocker User @relation("blocker", fields: [blockerId], references: [id], onDelete: Cascade)
  blocked User @relation("blocked", fields: [blockedId], references: [id], onDelete: Cascade)

  @@unique([blockerId, blockedId])
  @@index([blockerId])
  @@index([blockedId])
  @@map("blocks")
}

model NotificationPreference {
  id                    String   @id @default(cuid())
  userId                String   @unique
  emailNotifications    Boolean  @default(true)
  pushNotifications     Boolean  @default(true)
  smsNotifications      Boolean  @default(false)
  postLikes             Boolean  @default(true)
  postComments          Boolean  @default(true)
  newFollowers          Boolean  @default(true)
  mentions              Boolean  @default(true)
  directMessages        Boolean  @default(true)
  groupInvites          Boolean  @default(true)
  eventReminders        Boolean  @default(true)
  marketingEmails       Boolean  @default(false)
  weeklyDigest          Boolean  @default(true)
  quietHoursStart       String?  // Format: "HH:MM"
  quietHoursEnd         String?  // Format: "HH:MM"
  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@map("notification_preferences")
}

model Referral {
  id               String    @id @default(cuid())
  referrerId       String
  referredUserId   String?   @unique
  referralCode     String    @unique
  referredEmail    String?
  status           String    @default("PENDING")
  rewardClaimed    Boolean   @default(false)
  rewardAmount     Int       @default(100)
  expiresAt        DateTime?
  completedAt      DateTime?
  createdAt        DateTime  @default(now())

  // Relations
  referrer     User  @relation("referrer", fields: [referrerId], references: [id], onDelete: Cascade)
  referredUser User? @relation("referredUser", fields: [referredUserId], references: [id], onDelete: SetNull)

  @@index([referrerId])
  @@index([referralCode])
  @@index([status])
  @@map("referrals")
}

// =====================================================
// CONTENT MODELS
// =====================================================

model Category {
  id           String   @id @default(cuid())
  name         String
  slug         String   @unique
  description  String?  @db.Text
  icon         String?
  color        String?
  parentId     String?
  postCount    Int      @default(0)
  displayOrder Int      @default(0)
  isActive     Boolean  @default(true)
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  parent   Category? @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children Category[] @relation("CategoryHierarchy")
  posts    Post[]

  @@index([slug])
  @@index([parentId])
  @@index([isActive])
  @@map("categories")
}

model Post {
  id                 String         @id @default(cuid())
  slug               String         @unique
  title              String         @db.VarChar(500)
  content            Json
  contentType        ContentType    @default(BLOG)
  contentStatus      ContentStatus  @default(DRAFT)
  excerpt            String?        @db.Text
  coverImage         String?
  coverImageAlt      String?
  authorId           String
  categoryId         String?
  seriesId           String?
  seriesOrder        Int?
  published          Boolean        @default(false)
  featured           Boolean        @default(false)
  editorsPick        Boolean        @default(false)
  sponsoredContent   Boolean        @default(false)
  sponsorInfo        Json?
  isPinned           Boolean        @default(false)
  pinnedUntil        DateTime?
  isDraft            Boolean        @default(true)
  version            Int            @default(1)
  parentVersionId    String?
  collaborators      String[]       // User IDs who can edit
  youtubeVideoId     String?
  youtubeVideoData   Json?
  views              Int            @default(0)
  uniqueViews        Int            @default(0)
  readingTime        Int?           // In minutes
  wordCount          Int?
  metaTitle          String?        @db.VarChar(160)
  metaDescription    String?        @db.VarChar(320)
  metaKeywords       String[]
  ogImage            String?
  canonicalUrl       String?
  customSlug         Boolean        @default(false)
  allowComments      Boolean        @default(true)
  moderationStatus   ModerationStatus @default(PENDING)
  moderationNotes    String?        @db.Text
  scheduledPublishAt DateTime?
  publishedAt        DateTime?
  lastEditedAt       DateTime?
  archivedAt         DateTime?
  deletedAt          DateTime?
  createdAt          DateTime       @default(now())
  updatedAt          DateTime       @updatedAt

  // Relations
  author         User             @relation(fields: [authorId], references: [id], onDelete: Cascade)
  category       Category?        @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  series         PostSeries?      @relation(fields: [seriesId], references: [id], onDelete: SetNull)
  parentVersion  Post?            @relation("PostVersions", fields: [parentVersionId], references: [id], onDelete: SetNull)
  childVersions  Post[]           @relation("PostVersions")
  tags           PostTag[]
  comments       Comment[]
  reactions      Reaction[]
  poll           Poll?
  fanArtGallery  FanArtGallery?
  stats          PostStats?
  revisions      PostRevision[]
  viewHistory    ViewHistory[]
  relatedPosts   PostRelation[]   @relation("relatedPost")
  relatedTo      PostRelation[]   @relation("mainPost")
  mentions       Mention[]
  bookmarks      Bookmark[]

  @@index([slug])
  @@index([authorId])
  @@index([categoryId])
  @@index([seriesId])
  @@index([published, publishedAt(sort: Desc)])
  @@index([featured])
  @@index([contentType])
  @@index([scheduledPublishAt])
  @@index([contentStatus])
  @@index([moderationStatus])
  @@index([deletedAt])
  @@fulltext([title])
  @@map("posts")
}

model PostStats {
  id                String   @id @default(cuid())
  postId            String   @unique
  viewCount         Int      @default(0)
  uniqueViewCount   Int      @default(0)
  likeCount         Int      @default(0)
  loveCount         Int      @default(0)
  fireCount         Int      @default(0)
  totalReactionCount Int     @default(0)
  commentCount      Int      @default(0)
  shareCount        Int      @default(0)
  bookmarkCount     Int      @default(0)
  avgReadTime       Float    @default(0) // In seconds
  bounceRate        Float    @default(0)
  engagementRate    Float    @default(0)
  lastCalculatedAt  DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([postId])
  @@index([viewCount])
  @@index([totalReactionCount])
  @@index([engagementRate])
  @@map("post_stats")
}

model PostRevision {
  id           String   @id @default(cuid())
  postId       String
  editorId     String
  title        String   @db.VarChar(500)
  content      Json
  changeNote   String?  @db.Text
  version      Int
  isPublished  Boolean  @default(false)
  createdAt    DateTime @default(now())

  // Relations
  post   Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  editor User @relation(fields: [editorId], references: [id], onDelete: Cascade)

  @@index([postId, version])
  @@index([editorId])
  @@map("post_revisions")
}

model PostRelation {
  id            String   @id @default(cuid())
  postId        String
  relatedPostId String
  relationType  String   // "sequel", "prequel", "related", "translation"
  sortOrder     Int      @default(0)
  createdAt     DateTime @default(now())

  // Relations
  post        Post @relation("mainPost", fields: [postId], references: [id], onDelete: Cascade)
  relatedPost Post @relation("relatedPost", fields: [relatedPostId], references: [id], onDelete: Cascade)

  @@unique([postId, relatedPostId])
  @@index([postId])
  @@index([relatedPostId])
  @@map("post_relations")
}

model PostSeries {
  id           String   @id @default(cuid())
  title        String
  slug         String   @unique
  description  String?  @db.Text
  authorId     String
  coverImage   String?
  bannerImage  String?
  totalParts   Int      @default(0)
  completed    Boolean  @default(false)
  featured     Boolean  @default(false)
  metadata     Json?
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  author User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  posts  Post[]

  @@index([authorId])
  @@index([slug])
  @@index([featured])
  @@map("post_series")
}

model Tag {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?  @db.Text
  color       String?
  icon        String?
  postCount   Int      @default(0)
  featured    Boolean  @default(false)
  category    String?
  synonyms    String[]
  createdAt   DateTime @default(now())

  // Relations
  posts PostTag[]

  @@index([name])
  @@index([slug])
  @@index([featured])
  @@index([postCount])
  @@map("tags")
}

model PostTag {
  postId    String
  tagId     String
  addedBy   String?
  createdAt DateTime @default(now())

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@index([postId])
  @@index([tagId])
  @@map("post_tags")
}

model Comment {
  id                String           @id @default(cuid())
  content           String           @db.Text
  postId            String
  authorId          String
  parentId          String?
  youtubeTimestamp  Int?
  quotedTimestamp   String?          // For quoting specific video moments
  edited            Boolean          @default(false)
  editedAt          DateTime?
  editHistory       Json[]           // Store previous versions
  deleted           Boolean          @default(false)
  deletedAt         DateTime?
  deletedBy         String?
  pinned            Boolean          @default(false)
  featured          Boolean          @default(false)
  moderationStatus  ModerationStatus @default(AUTO_APPROVED)
  moderationNotes   String?
  ipAddress         String?
  userAgent         String?
  version           Int              @default(0)
  createdAt         DateTime         @default(now())
  updatedAt         DateTime         @updatedAt

  // Relations
  post      Post       @relation(fields: [postId], references: [id], onDelete: Cascade)
  author    User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent    Comment?   @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]  @relation("CommentReplies")
  reactions Reaction[]
  mentions  Mention[]

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
  @@index([youtubeTimestamp])
  @@index([moderationStatus])
  @@index([deleted])
  @@map("comments")
}

model Reaction {
  id          String       @id @default(cuid())
  type        ReactionType
  postId      String?
  commentId   String?
  userId      String
  customEmoji String?      // For CUSTOM type
  metadata    Json?
  createdAt   DateTime     @default(now())

  // Relations
  post    Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId, type])
  @@unique([commentId, userId, type])
  @@index([postId])
  @@index([commentId])
  @@index([userId])
  @@index([type])
  @@map("reactions")
}

model Mention {
  id           String   @id @default(cuid())
  mentionerId  String
  mentionedId  String
  postId       String?
  commentId    String?
  context      String?  @db.Text
  acknowledged Boolean  @default(false)
  createdAt    DateTime @default(now())

  // Relations
  mentioner User     @relation(fields: [mentionerId], references: [id], onDelete: Cascade)
  mentioned User     @relation(fields: [mentionedId], references: [id], onDelete: Cascade)
  post      Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment   Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)

  @@index([mentionedId])
  @@index([postId])
  @@index([commentId])
  @@map("mentions")
}

model Bookmark {
  id         String   @id @default(cuid())
  userId     String
  postId     String
  folderId   String?
  notes      String?  @db.Text
  tags       String[]
  createdAt  DateTime @default(now())

  // Relations
  user   User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  post   Post            @relation(fields: [postId], references: [id], onDelete: Cascade)
  folder BookmarkFolder? @relation(fields: [folderId], references: [id], onDelete: SetNull)

  @@unique([userId, postId])
  @@index([userId])
  @@index([postId])
  @@index([folderId])
  @@map("bookmarks")
}

model BookmarkFolder {
  id          String     @id @default(cuid())
  userId      String
  name        String
  description String?
  color       String?
  icon        String?
  isPublic    Boolean    @default(false)
  sortOrder   Int        @default(0)
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt

  // Relations
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  bookmarks Bookmark[]

  @@unique([userId, name])
  @@index([userId])
  @@map("bookmark_folders")
}

model Follow {
  id             String    @id @default(cuid())
  followerId     String
  followingId    String
  notifyNewPosts Boolean   @default(true)
  notifyActivity Boolean   @default(false)
  createdAt      DateTime  @default(now())

  // Relations
  follower  User @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
  @@map("follows")
}

model ViewHistory {
  id           String    @id @default(cuid())
  userId       String
  postId       String
  viewDuration Int       @default(0) // In seconds
  scrollDepth  Float     @default(0) // Percentage
  referrer     String?
  deviceType   String?
  createdAt    DateTime  @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([postId])
  @@map("view_history")
}

model SearchHistory {
  id          String   @id @default(cuid())
  userId      String?
  query       String
  resultCount Int      @default(0)
  clickedResults String[]
  searchType  String?  // "posts", "users", "tags", etc.
  deviceType  String?
  createdAt   DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([query])
  @@index([createdAt])
  @@map("search_history")
}

// =====================================================
// NOTIFICATION MODELS
// =====================================================

model Notification {
  id           String           @id @default(cuid())
  type         NotificationType
  userId       String
  actorId      String?
  entityId     String?
  entityType   String?
  title        String
  message      String           @db.Text
  data         Json?
  imageUrl     String?
  actionUrl    String?
  priority     Int              @default(0) // 0=low, 1=normal, 2=high
  read         Boolean          @default(false)
  readAt       DateTime?
  clicked      Boolean          @default(false)
  clickedAt    DateTime?
  emailSent    Boolean          @default(false)
  pushSent     Boolean          @default(false)
  smsSent      Boolean          @default(false)
  dismissed    Boolean          @default(false)
  dismissedAt  DateTime?
  expiresAt    DateTime?
  createdAt    DateTime         @default(now())

  // Relations
  user  User  @relation("notificationUser", fields: [userId], references: [id], onDelete: Cascade)
  actor User? @relation("notificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, read, createdAt(sort: Desc)])
  @@index([actorId])
  @@index([type])
  @@index([priority])
  @@index([expiresAt])
  @@map("notifications")
}

model NotificationQueue {
  id            String   @id @default(cuid())
  userId        String
  type          String
  channel       String   // "email", "push", "sms"
  payload       Json
  priority      Int      @default(0)
  attempts      Int      @default(0)
  maxAttempts   Int      @default(3)
  scheduledFor  DateTime @default(now())
  processedAt   DateTime?
  failedAt      DateTime?
  error         String?  @db.Text
  createdAt     DateTime @default(now())

  @@index([scheduledFor, processedAt])
  @@index([userId])
  @@index([priority])
  @@map("notification_queue")
}

// =====================================================
// GAMIFICATION MODELS
// =====================================================

model Achievement {
  id                   String      @id @default(cuid())
  code                 String      @unique
  name                 String
  description          String?     @db.Text
  shortDescription     String?
  icon                 String?
  animatedIcon         String?
  bannerImage          String?
  xpReward             Int         @default(0)
  sparklePointsReward  Int         @default(0)
  premiumPointsReward  Int         @default(0)
  rarity               BadgeRarity @default(COMMON)
  category             String?
  subcategory          String?
  criteria             Json?
  progressSteps        Int         @default(1)
  isSecret             Boolean     @default(false)
  prerequisiteIds      String[]
  displayOrder         Int         @default(0)
  seasonal             Boolean     @default(false)
  eventBased           Boolean     @default(false)
  limited              Boolean     @default(false)
  maxAchievers         Int?        // For limited edition
  expiresAt            DateTime?
  metadata             Json?
  createdAt            DateTime    @default(now())
  updatedAt            DateTime    @updatedAt

  // Relations
  userAchievements UserAchievement[]

  @@index([code])
  @@index([category])
  @@index([rarity])
  @@map("achievements")
}

model UserAchievement {
  id              String   @id @default(cuid())
  userId          String
  achievementId   String
  progress        Float    @default(0) // 0 to 1
  progressData    Json?
  unlockedAt      DateTime @default(now())
  showcased       Boolean  @default(false)
  showcaseOrder   Int      @default(0)
  notified        Boolean  @default(false)
  claimedRewards  Boolean  @default(false)

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([userId, showcased])
  @@index([achievementId])
  @@map("user_achievements")
}

model XpLog {
  id          String   @id @default(cuid())
  userId      String
  amount      Int
  source      String   // "post_create", "comment", "like_received", etc.
  sourceId    String?  // Reference to the source entity
  reason      String?
  multiplier  Float    @default(1)
  bonusXp     Int      @default(0)
  totalXp     Int      // Total XP after this transaction
  metadata    Json?
  createdAt   DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([source])
  @@map("xp_logs")
}

model LevelConfig {
  level           Int      @id
  requiredXp      Int
  title           String
  perks           String[]
  sparkleReward   Int      @default(0)
  premiumReward   Int      @default(0)
  unlockFeatures  String[]
  badgeId         String?
  createdAt       DateTime @default(now())

  @@index([requiredXp])
  @@map("level_configs")
}

model CurrencyTransaction {
  id              String   @id @default(cuid())
  userId          String
  amount          Int
  currencyType    String   // "sparkle", "premium"
  transactionType String   // "earn", "spend", "transfer", "refund"
  source          String   // "achievement", "purchase", "trade", etc.
  sourceId        String?
  description     String?
  referenceId     String?
  referenceType   String?
  balanceBefore   Int
  balanceAfter    Int
  metadata        Json?
  createdAt       DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([transactionType])
  @@index([source])
  @@map("currency_transactions")
}

model StoreItem {
  id                 String    @id @default(cuid())
  sku                String    @unique
  name               String
  description        String?   @db.Text
  shortDescription   String?
  category           String
  subcategory        String?
  itemType           String    // "avatar", "badge", "theme", "reaction", etc.
  rarity             BadgeRarity @default(COMMON)
  priceSparkle       Int?
  pricePremium       Int?
  originalPriceSparkle Int?
  originalPricePremium Int?
  discountPercentage Int       @default(0)
  previewUrl         String?
  thumbnailUrl       String?
  images             String[]
  data               Json?     // Item-specific data
  requirements       Json?     // Level, achievement requirements
  limitedEdition     Boolean   @default(false)
  stockRemaining     Int?
  maxPerUser         Int?
  featured           Boolean   @default(false)
  new                Boolean   @default(false)
  availableFrom      DateTime?
  availableUntil     DateTime?
  metadata           Json?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  inventory UserInventory[]
  bundles   StoreBundle[]   @relation("BundleItems")

  @@index([category])
  @@index([featured])
  @@index([availableFrom, availableUntil])
  @@map("store_items")
}

model StoreBundle {
  id                 String    @id @default(cuid())
  name               String
  description        String?
  priceSparkle       Int?
  pricePremium       Int?
  discountPercentage Int       @default(0)
  items              StoreItem[] @relation("BundleItems")
  availableFrom      DateTime?
  availableUntil     DateTime?
  maxPurchases       Int?
  createdAt          DateTime  @default(now())

  @@index([availableFrom, availableUntil])
  @@map("store_bundles")
}

model UserInventory {
  id            String    @id @default(cuid())
  userId        String
  itemId        String
  quantity      Int       @default(1)
  equipped      Boolean   @default(false)
  equippedAt    DateTime?
  customData    Json?     // User customizations
  acquiredFrom  String    // "purchase", "achievement", "gift", etc.
  acquiredAt    DateTime  @default(now())
  expiresAt     DateTime?
  tradeable     Boolean   @default(true)
  giftedBy      String?

  // Relations
  user User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  item StoreItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@index([userId])
  @@index([userId, equipped])
  @@index([itemId])
  @@map("user_inventory")
}

model Trade {
  id              String      @id @default(cuid())
  initiatorId     String
  recipientId     String
  status          TradeStatus @default(PENDING)
  initiatorItems  Json        // Array of {itemId, quantity}
  recipientItems  Json        // Array of {itemId, quantity}
  initiatorPoints Int         @default(0)
  recipientPoints Int         @default(0)
  message         String?     @db.Text
  responseMessage String?     @db.Text
  tradeValue      Int         @default(0) // Estimated value
  escrowId        String?     // For secure trading
  expiresAt       DateTime    @default(dbgenerated("(CURRENT_TIMESTAMP + interval '7 days')"))
  respondedAt     DateTime?
  completedAt     DateTime?
  cancelledAt     DateTime?
  cancelReason    String?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  initiator User @relation("tradeInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  recipient User @relation("tradeRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([initiatorId, status])
  @@index([recipientId, status])
  @@index([status])
  @@map("trades")
}

model Quest {
  id               String    @id @default(cuid())
  code             String    @unique
  name             String
  description      String?   @db.Text
  shortDescription String?
  icon             String?
  bannerImage      String?
  type             QuestType
  category         String?
  difficulty       String?   // "easy", "medium", "hard", "epic"
  requirements     Json      // Quest completion criteria
  rewards          Json      // Rewards specification
  xpReward         Int       @default(0)
  pointsReward     Int       @default(0)
  prerequisiteIds  String[]  // Required quests
  levelRequired    Int       @default(1)
  cooldownHours    Int?      // For repeatable quests
  maxCompletions   Int       @default(1)
  timeLimit        Int?      // In minutes
  availableFrom    DateTime?
  availableUntil   DateTime?
  metadata         Json?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  userQuests UserQuest[]

  @@index([type])
  @@index([availableFrom, availableUntil])
  @@map("quests")
}

model UserQuest {
  id            String      @id @default(cuid())
  userId        String
  questId       String
  status        QuestStatus @default(AVAILABLE)
  progress      Json        @default("{}")
  currentStep   Int         @default(0)
  totalSteps    Int         @default(1)
  startedAt     DateTime    @default(now())
  completedAt   DateTime?
  claimedAt     DateTime?
  expiresAt     DateTime?
  attemptCount  Int         @default(1)
  bestTime      Int?        // In seconds
  metadata      Json?

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  quest Quest @relation(fields: [questId], references: [id], onDelete: Cascade)

  @@unique([userId, questId])
  @@index([userId, status])
  @@index([questId])
  @@index([status])
  @@map("user_quests")
}

model Leaderboard {
  id          String   @id @default(cuid())
  type        String   // "xp", "sparkle", "posts", "achievements", etc.
  scope       String   // "global", "regional", "group"
  scopeId     String?  // Group ID, region code, etc.
  period      String   // "daily", "weekly", "monthly", "alltime"
  periodStart DateTime
  periodEnd   DateTime
  data        Json     // Sorted leaderboard data
  metadata    Json?
  processed   Boolean  @default(false)
  createdAt   DateTime @default(now())

  @@unique([type, scope, scopeId, periodStart, periodEnd])
  @@index([type, periodEnd(sort: Desc)])
  @@index([processed])
  @@map("leaderboards")
}

model LeaderboardEntry {
  id          String   @id @default(cuid())
  userId      String
  type        String
  period      String
  rank        Int
  score       BigInt
  movement    Int      @default(0) // Rank change from previous period
  metadata    Json?
  createdAt   DateTime @default(now())

  @@unique([userId, type, period])
  @@index([type, period, rank])
  @@index([userId])
  @@map("leaderboard_entries")
}

// =====================================================
// YOUTUBE INTEGRATION MODELS
// =====================================================

model YoutubeChannel {
  id                   String    @id @default(cuid())
  channelId            String    @unique
  userId               String?
  channelTitle         String?
  channelHandle        String?
  channelDescription   String?   @db.Text
  channelData          Json?
  thumbnailUrl         String?
  bannerUrl            String?
  subscriberCount      BigInt    @default(0)
  viewCount            BigInt    @default(0)
  videoCount           Int       @default(0)
  lastVideoId          String?
  lastVideoTitle       String?
  lastVideoPublishedAt DateTime?
  lastSyncedAt         DateTime?
  syncEnabled          Boolean   @default(true)
  featured             Boolean   @default(false)
  verified             Boolean   @default(false)
  metadata             Json?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Relations
  user   User?           @relation(fields: [userId], references: [id], onDelete: SetNull)
  videos YoutubeVideo[]

  @@index([userId])
  @@index([channelId])
  @@index([featured])
  @@map("youtube_channels")
}

model YoutubeVideo {
  id                 String    @id @default(cuid())
  videoId            String    @unique
  channelId          String
  youtubeChannelId   String?
  title              String?   @db.VarChar(500)
  description        String?   @db.Text
  thumbnailUrl       String?
  thumbnailUrlHd     String?
  duration           Int?      // In seconds
  durationFormatted  String?   // "HH:MM:SS"
  viewCount          BigInt    @default(0)
  likeCount          Int       @default(0)
  commentCount       Int       @default(0)
  tags               String[]
  categoryId         String?
  liveBroadcast      Boolean   @default(false)
  premiereDate       DateTime?
  publishedAt        DateTime?
  metadata           Json?
  lastSyncedAt       DateTime?
  createdAt          DateTime  @default(now())

  // Relations
  channel      YoutubeChannel? @relation(fields: [youtubeChannelId], references: [id], onDelete: SetNull)
  watchParties WatchParty[]
  clips        VideoClip[]
  analytics    VideoAnalytics?

  @@index([channelId])
  @@index([publishedAt(sort: Desc)])
  @@index([viewCount])
  @@map("youtube_videos")
}

model VideoAnalytics {
  id                  String   @id @default(cuid())
  videoId             String   @unique
  watchTime           BigInt   @default(0) // Total seconds watched
  avgWatchTime        Float    @default(0)
  completionRate      Float    @default(0)
  engagementRate      Float    @default(0)
  clipCount           Int      @default(0)
  shareCount          Int      @default(0)
  discussionCount     Int      @default(0)
  sentimentScore      Float?   // -1 to 1
  topDiscussionTopics String[]
  peakViewers         Int      @default(0)
  updatedAt           DateTime @updatedAt

  // Relations
  video YoutubeVideo @relation(fields: [videoId], references: [videoId], onDelete: Cascade)

  @@index([videoId])
  @@map("video_analytics")
}

model WatchParty {
  id                String       @id @default(cuid())
  hostId            String
  title             String
  description       String?      @db.Text
  youtubeVideoId    String
  youtubeVideoUrl   String?
  scheduledStart    DateTime
  actualStart       DateTime?
  endedAt           DateTime?
  maxParticipants   Int          @default(50)
  currentParticipants Int        @default(0)
  isPublic          Boolean      @default(true)
  requiresApproval  Boolean      @default(false)
  chatEnabled       Boolean      @default(true)
  syncPlayback      Boolean      @default(true)
  allowGuestChat    Boolean      @default(false)
  recordChat        Boolean      @default(true)
  tags              String[]
  customEmotes      Json?
  partyCode         String?      @unique
  cancelledAt       DateTime?
  cancelReason      String?
  metadata          Json?
  createdAt         DateTime     @default(now())
  updatedAt         DateTime     @updatedAt

  // Relations
  host         User                     @relation(fields: [hostId], references: [id], onDelete: Cascade)
  video        YoutubeVideo?            @relation(fields: [youtubeVideoId], references: [videoId], onDelete: SetNull)
  participants WatchPartyParticipant[]
  chat         WatchPartyChat[]

  @@index([hostId])
  @@index([scheduledStart])
  @@index([isPublic, scheduledStart])
  @@index([partyCode])
  @@map("watch_parties")
}

model WatchPartyParticipant {
  id               String    @id @default(cuid())
  partyId          String
  userId           String
  role             String    @default("viewer") // "host", "moderator", "viewer"
  joinedAt         DateTime  @default(now())
  leftAt           DateTime?
  isActive         Boolean   @default(true)
  playbackPosition Int       @default(0)
  isMuted          Boolean   @default(false)
  isBanned         Boolean   @default(false)
  bannedAt         DateTime?
  banReason        String?
  messageCount     Int       @default(0)
  reactionCount    Int       @default(0)

  // Relations
  party WatchParty @relation(fields: [partyId], references: [id], onDelete: Cascade)
  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([partyId, userId])
  @@index([partyId, isActive])
  @@index([userId])
  @@map("watch_party_participants")
}

model WatchPartyChat {
  id          String    @id @default(cuid())
  partyId     String
  userId      String
  message     String    @db.Text
  timestamp   Int       // Video timestamp when message was sent
  replyToId   String?
  reactions   Json?     // Quick reactions to messages
  deleted     Boolean   @default(false)
  deletedAt   DateTime?
  deletedBy   String?
  createdAt   DateTime  @default(now())

  // Relations
  party   WatchParty      @relation(fields: [partyId], references: [id], onDelete: Cascade)
  user    User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo WatchPartyChat? @relation("WatchPartyChatReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies WatchPartyChat[] @relation("WatchPartyChatReplies")

  @@index([partyId, createdAt])
  @@index([userId])
  @@map("watch_party_chat")
}

model VideoClip {
  id             String   @id @default(cuid())
  youtubeVideoId String
  creatorId      String
  title          String
  description    String?  @db.Text
  startTime      Int      // In seconds
  endTime        Int      // In seconds
  duration       Int      // Calculated: endTime - startTime
  thumbnailUrl   String?
  tags           String[]
  viewCount      Int      @default(0)
  likeCount      Int      @default(0)
  shareCount     Int      @default(0)
  featured       Boolean  @default(false)
  metadata       Json?
  createdAt      DateTime @default(now())

  // Relations
  video   YoutubeVideo? @relation(fields: [youtubeVideoId], references: [videoId], onDelete: SetNull)
  creator User          @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([youtubeVideoId])
  @@index([creatorId])
  @@index([viewCount])
  @@map("video_clips")
}

model Playlist {
  id              String   @id @default(cuid())
  title           String
  slug            String   @unique
  description     String?  @db.Text
  ownerId         String
  isCollaborative Boolean  @default(false)
  collaboratorIds String[]
  isPublic        Boolean  @default(true)
  coverImage      String?
  tags            String[]
  viewCount       Int      @default(0)
  likeCount       Int      @default(0)
  followerCount   Int      @default(0)
  itemCount       Int      @default(0)
  totalDuration   Int      @default(0) // In seconds
  featured        Boolean  @default(false)
  metadata        Json?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  owner User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  items PlaylistItem[]

  @@index([ownerId])
  @@index([isPublic])
  @@index([slug])
  @@map("playlists")
}

model PlaylistItem {
  id             String   @id @default(cuid())
  playlistId     String
  youtubeVideoId String
  addedBy        String
  position       Int
  note           String?  @db.Text
  customTitle    String?
  startTime      Int?     // Custom start time
  endTime        Int?     // Custom end time
  addedAt        DateTime @default(now())

  // Relations
  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [addedBy], references: [id], onDelete: Cascade)

  @@unique([playlistId, position])
  @@index([playlistId])
  @@index([addedBy])
  @@map("playlist_items")
}

model YouTubeApiQuota {
  id            String   @id @default(cuid())
  date          DateTime @default(dbgenerated("CURRENT_DATE"))
  unitsUsed     Int      @default(0)
  quotaLimit    Int      @default(10000)
  readRequests  Int      @default(0)
  writeRequests Int      @default(0)
  searchRequests Int     @default(0)
  resetAt       DateTime
  
  @@unique([date])
  @@index([date])
  @@map("youtube_api_quota")
}

// =====================================================
// SOCIAL FEATURES MODELS
// =====================================================

model Group {
  id              String          @id @default(cuid())
  name            String
  slug            String          @unique
  description     String?         @db.Text
  shortDescription String?
  bannerImage     String?
  icon            String?
  coverImage      String?
  ownerId         String
  visibility      GroupVisibility @default(PUBLIC)
  joinApproval    Boolean         @default(false)
  memberCount     Int             @default(1)
  postCount       Int             @default(0)
  onlineCount     Int             @default(0)
  rules           String?         @db.Text
  guidelines      Json?
  tags            String[]
  categories      String[]
  settings        Json            @default("{}")
  features        String[]        // Enabled features for the group
  customEmojis    Json?
  isOfficial      Boolean         @default(false)
  isVerified      Boolean         @default(false)
  isFeatured      Boolean         @default(false)
  metadata        Json?
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  // Relations
  owner    User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  members  GroupMember[]
  events   Event[]
  posts    GroupPost[]
  channels GroupChannel[]

  @@index([slug])
  @@index([ownerId])
  @@index([visibility])
  @@index([isFeatured])
  @@map("groups")
}

model GroupMember {
  id            String          @id @default(cuid())
  groupId       String
  userId        String
  role          GroupMemberRole @default(MEMBER)
  permissions   String[]
  joinedAt      DateTime        @default(now())
  invitedBy     String?
  approvedBy    String?
  mutedUntil    DateTime?
  bannedUntil   DateTime?
  banReason     String?
  contribution  Int             @default(0) // Group-specific points
  lastActiveAt  DateTime        @default(now())
  notifications Boolean         @default(true)

  // Relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId, role])
  @@index([userId])
  @@map("group_members")
}

model GroupPost {
  id               String           @id @default(cuid())
  groupId          String
  authorId         String
  title            String?
  content          String           @db.Text
  isPinned         Boolean          @default(false)
  isAnnouncement   Boolean          @default(false)
  allowComments    Boolean          @default(true)
  viewCount        Int              @default(0)
  reactionCount    Int              @default(0)
  commentCount     Int              @default(0)
  moderationStatus ModerationStatus @default(AUTO_APPROVED)
  createdAt        DateTime         @default(now())
  updatedAt        DateTime         @updatedAt

  // Relations
  group  Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  author User  @relation(fields: [authorId], references: [id], onDelete: Cascade)

  @@index([groupId, createdAt(sort: Desc)])
  @@index([authorId])
  @@map("group_posts")
}

model GroupChannel {
  id          String   @id @default(cuid())
  groupId     String
  name        String
  description String?
  type        String   // "text", "voice", "announcement"
  position    Int      @default(0)
  permissions Json?
  createdAt   DateTime @default(now())

  // Relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)

  @@unique([groupId, name])
  @@index([groupId])
  @@map("group_channels")
}

model Event {
  id               String       @id @default(cuid())
  title            String
  slug             String       @unique
  description      String?      @db.Text
  shortDescription String?
  type             EventType
  status           EventStatus  @default(SCHEDULED)
  hostId           String
  cohostIds        String[]
  groupId          String?
  locationName     String?
  locationUrl      String?
  locationAddress  String?
  locationCoords   Json?        // {lat, lng}
  isVirtual        Boolean      @default(false)
  virtualPlatform  String?      // "zoom", "discord", "youtube", etc.
  virtualLink      String?
  bannerImage      String?
  thumbnailImage   String?
  startTime        DateTime
  endTime          DateTime
  timezone         String       @default("UTC")
  recurrence       Json?        // Recurrence rules
  maxAttendees     Int?
  currentAttendees Int          @default(0)
  minAttendees     Int?
  isPublic         Boolean      @default(true)
  requiresApproval Boolean      @default(false)
  requiresPayment  Boolean      @default(false)
  price            Int?
  currency         String?
  tags             String[]
  categories       String[]
  agenda           Json?
  speakers         Json?
  sponsors         Json?
  streamUrl        String?
  recordingUrl     String?
  materials        Json?        // Links to materials
  feedback         Json?        // Post-event feedback settings
  remindersSent    String[]     // Track which reminders have been sent
  metadata         Json?
  cancelledAt      DateTime?
  cancelReason     String?
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt

  // Relations
  host      User            @relation(fields: [hostId], references: [id], onDelete: Cascade)
  group     Group?          @relation(fields: [groupId], references: [id], onDelete: SetNull)
  attendees EventAttendee[]

  @@index([hostId])
  @@index([groupId])
  @@index([startTime])
  @@index([isPublic, startTime])
  @@index([status])
  @@index([slug])
  @@map("events")
}

model EventAttendee {
  id              String    @id @default(cuid())
  eventId         String
  userId          String
  status          String    @default("INTERESTED") // "INTERESTED", "GOING", "NOT_GOING", "WAITLISTED"
  role            String    @default("ATTENDEE") // "ATTENDEE", "SPEAKER", "ORGANIZER", "VOLUNTEER"
  approved        Boolean   @default(true)
  approvedAt      DateTime?
  approvedBy      String?
  checkInTime     DateTime?
  checkInMethod   String?   // "manual", "qr", "auto"
  attended        Boolean   @default(false)
  rating          Int?      // Post-event rating 1-5
  feedback        String?   @db.Text
  certificateId   String?   // For events that issue certificates
  notes           String?   @db.Text
  remindersSent   Boolean   @default(false)
  createdAt       DateTime  @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId, status])
  @@index([userId])
  @@map("event_attendees")
}

// =====================================================
// MESSAGING MODELS
// =====================================================

model Conversation {
  id                String   @id @default(cuid())
  isGroup           Boolean  @default(false)
  title             String?
  description       String?
  icon              String?
  encryptedKey      String?  @db.Text
  lastMessageId     String?
  lastMessageAt     DateTime?
  messageCount      Int      @default(0)
  createdBy         String
  settings          Json     @default("{}")
  pinnedMessages    String[]
  isArchived        Boolean  @default(false)
  archivedAt        DateTime?
  deletedAt         DateTime?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  // Relations
  creator      User                      @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  participants ConversationParticipant[]
  messages     Message[]

  @@index([createdBy])
  @@index([lastMessageAt])
  @@map("conversations")
}

model ConversationParticipant {
  id                 String    @id @default(cuid())
  conversationId     String
  userId             String
  nickname           String?
  role               String    @default("member") // "admin", "member"
  joinedAt           DateTime  @default(now())
  leftAt             DateTime?
  isActive           Boolean   @default(true)
  lastReadAt         DateTime?
  lastReadMessageId  String?
  unreadCount        Int       @default(0)
  notificationsMuted Boolean   @default(false)
  mutedUntil         DateTime?
  isPinned           Boolean   @default(false)
  customSettings     Json?

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
  @@index([userId, isPinned])
  @@map("conversation_participants")
}

model Message {
  id              String        @id @default(cuid())
  conversationId  String
  senderId        String
  content         String?       @db.Text
  encryptedContent String?      @db.Text
  messageType     String        @default("TEXT") // "TEXT", "IMAGE", "VIDEO", "FILE", "AUDIO", "SYSTEM"
  attachments     Json?         // Array of attachment objects
  mentions        String[]      // User IDs mentioned
  replyToId       String?
  forwardedFrom   String?
  reactions       Json?         // { "": ["userId1", "userId2"], ... }
  metadata        Json?
  edited          Boolean       @default(false)
  editedAt        DateTime?
  editHistory     Json[]
  deleted         Boolean       @default(false)
  deletedAt       DateTime?
  deletedFor      String[]      // User IDs who deleted this message
  status          MessageStatus @default(SENT)
  deliveredAt     DateTime?
  errorMessage    String?
  createdAt       DateTime      @default(now())

  // Relations
  conversation Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  replyTo      Message?      @relation("MessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies      Message[]     @relation("MessageReplies")
  reads        MessageRead[]

  @@index([conversationId, createdAt(sort: Desc)])
  @@index([senderId])
  @@map("messages")
}

model MessageRead {
  messageId String
  userId    String
  readAt    DateTime @default(now())

  // Relations
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId])
  @@index([userId])
  @@map("message_reads")
}

// =====================================================
// REAL-TIME SUPPORT MODELS
// =====================================================

model WebsocketSession {
  id           String   @id @default(cuid())
  userId       String
  socketId     String   @unique
  ipAddress    String?
  userAgent    String?  @db.Text
  deviceType   String?
  location     String?
  connectedAt  DateTime @default(now())
  lastPingAt   DateTime @default(now())
  disconnectReason String?

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([socketId])
  @@map("websocket_sessions")
}

model ChatRoom {
  id           String   @id @default(cuid())
  name         String
  slug         String   @unique
  description  String?  @db.Text
  topic        String?
  tags         String[]
  isPublic     Boolean  @default(true)
  isModerated  Boolean  @default(false)
  isPersistent Boolean  @default(true) // False for temporary rooms
  maxUsers     Int      @default(100)
  activeUsers  Int      @default(0)
  totalMessages Int     @default(0)
  slowMode     Int      @default(0) // Seconds between messages
  customEmojis Json?
  rules        String?  @db.Text
  welcomeMessage String?
  pinnedMessage String?
  blockedWords String[]
  createdBy    String
  moderatorIds String[]
  expiresAt    DateTime? // For temporary rooms
  lastActiveAt DateTime @default(now())
  createdAt    DateTime @default(now())

  // Relations
  creator  User          @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  messages ChatMessage[]

  @@index([slug])
  @@index([isPublic])
  @@index([lastActiveAt])
  @@map("chat_rooms")
}

model ChatMessage {
  id           String    @id @default(cuid())
  roomId       String
  userId       String
  content      String    @db.Text
  mentions     String[]
  attachments  Json?
  replyToId    String?
  systemMessage Boolean  @default(false)
  highlighted  Boolean  @default(false)
  reactions    Json?    // { "": 5, "": 3 }
  edited       Boolean  @default(false)
  editedAt     DateTime?
  deleted      Boolean  @default(false)
  deletedAt    DateTime?
  deletedBy    String?
  flagged      Boolean  @default(false)
  flagReason   String?
  createdAt    DateTime @default(now())

  // Relations
  room    ChatRoom     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo ChatMessage? @relation("ChatMessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies ChatMessage[] @relation("ChatMessageReplies")

  @@index([roomId, createdAt(sort: Desc)])
  @@index([userId])
  @@map("chat_messages")
}

model CollaborativeSpace {
  id               String   @id @default(cuid())
  type             String   // "document", "whiteboard", "code", "canvas"
  title            String
  description      String?  @db.Text
  ownerId          String
  content          Json?
  version          Int      @default(1)
  isPublic         Boolean  @default(false)
  isTemplate       Boolean  @default(false)
  allowAnonymous   Boolean  @default(false)
  maxCollaborators Int      @default(10)
  activeUsers      Int      @default(0)
  editPermission   String   @default("collaborators") // "owner", "collaborators", "anyone"
  viewPermission   String   @default("anyone") // "owner", "collaborators", "anyone"
  forkable         Boolean  @default(true)
  forkCount        Int      @default(0)
  parentId         String?  // For forked spaces
  tags             String[]
  lastEditedAt     DateTime @default(now())
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  owner         User                @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  collaborators SpaceCollaborator[]

  @@index([ownerId])
  @@index([type])
  @@index([isPublic])
  @@map("collaborative_spaces")
}

model SpaceCollaborator {
  id            String   @id @default(cuid())
  spaceId       String
  userId        String
  role          String   @default("editor") // "viewer", "editor", "admin"
  canEdit       Boolean  @default(true)
  canComment    Boolean  @default(true)
  canInvite     Boolean  @default(false)
  lastActiveAt  DateTime @default(now())
  joinedAt      DateTime @default(now())
  invitedBy     String?

  // Relations
  space CollaborativeSpace @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  user  User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([spaceId, userId])
  @@index([spaceId])
  @@index([userId])
  @@map("space_collaborators")
}

model PresenceTracking {
  id            String   @id @default(cuid())
  userId        String
  location      String   // "post:123", "room:abc", "space:xyz"
  locationType  String   // "post", "room", "space", "profile"
  deviceId      String?
  status        String   @default("active") // "active", "idle", "away"
  lastActiveAt  DateTime @default(now())
  metadata      Json?    // Additional context

  @@unique([userId, location])
  @@index([location])
  @@index([userId])
  @@map("presence_tracking")
}

// =====================================================
// ACTIVITY & ANALYTICS MODELS
// =====================================================

model ActivityStream {
  id         String   @id @default(cuid())
  userId     String
  action     String   // "post.created", "user.followed", "achievement.unlocked"
  entityType String   // "post", "user", "comment", etc.
  entityId   String
  entityData Json?    // Snapshot of entity at time of action
  metadata   Json?
  visibility String   @default("PUBLIC") // "PUBLIC", "FOLLOWERS", "PRIVATE"
  ipAddress  String?
  userAgent  String?
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([entityType, entityId])
  @@index([action])
  @@map("activity_streams")
}

model UserActivity {
  id               String   @id @default(cuid())
  userId           String   @unique
  date             DateTime @default(dbgenerated("CURRENT_DATE"))
  loginCount       Int      @default(0)
  pageViews        Int      @default(0)
  postsCreated     Int      @default(0)
  postsViewed      Int      @default(0)
  commentsCreated  Int      @default(0)
  reactionsGiven   Int      @default(0)
  messagessSent    Int      @default(0)
  minutesActive    Int      @default(0)
  xpEarned         Int      @default(0)
  pointsEarned     Int      @default(0)
  achievementsUnlocked Int  @default(0)

  @@unique([userId, date])
  @@index([date])
  @@map("user_activity")
}

model ContentPerformance {
  id               String   @id @default(cuid())
  contentType      String   // "post", "comment", "video"
  contentId        String
  date             DateTime @default(dbgenerated("CURRENT_DATE"))
  impressions      Int      @default(0)
  uniqueImpressions Int     @default(0)
  clicks           Int      @default(0)
  engagements      Int      @default(0)
  shares           Int      @default(0)
  avgTimeSpent     Float    @default(0)
  bounceRate       Float    @default(0)
  viralityScore    Float    @default(0)

  @@unique([contentType, contentId, date])
  @@index([contentType, date])
  @@index([viralityScore])
  @@map("content_performance")
}

// =====================================================
// CONTENT VARIATION MODELS
// =====================================================

model Poll {
  id              String    @id @default(cuid())
  postId          String    @unique
  question        String    @db.Text
  multipleChoice  Boolean   @default(false)
  anonymousVoting Boolean   @default(false)
  showResults     String    @default("after_vote") // "always", "after_vote", "after_close"
  requireComment  Boolean   @default(false)
  minChoices      Int       @default(1)
  maxChoices      Int       @default(1)
  closeAt         DateTime?
  finalResults    Json?     // Cached final results
  createdAt       DateTime  @default(now())

  // Relations
  post    Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  options PollOption[]
  votes   PollVote[]

  @@index([postId])
  @@map("polls")
}

model PollOption {
  id           String   @id @default(cuid())
  pollId       String
  optionText   String   @db.Text
  description  String?
  imageUrl     String?
  displayOrder Int
  voteCount    Int      @default(0)
  percentage   Float    @default(0)
  metadata     Json?

  // Relations
  poll  Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes PollVote[]

  @@index([pollId])
  @@map("poll_options")
}

model PollVote {
  id        String   @id @default(cuid())
  pollId    String
  optionIds String[] // Support for multiple choice
  userId    String
  comment   String?  @db.Text
  ipAddress String?
  metadata  Json?
  createdAt DateTime @default(now())

  // Relations
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  option PollOption @relation(fields: [optionIds[0]], references: [id], onDelete: Cascade)
  user   User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([pollId, userId])
  @@index([pollId])
  @@index([userId])
  @@map("poll_votes")
}

model FanArtGallery {
  id                    String    @id @default(cuid())
  postId                String    @unique
  theme                 String?
  rules                 String?   @db.Text
  prizes                Json?
  submissionDeadline    DateTime?
  votingDeadline        DateTime?
  votingEnabled         Boolean   @default(true)
  publicVoting          Boolean   @default(true)
  maxSubmissionsPerUser Int       @default(3)
  requireApproval       Boolean   @default(false)
  allowNSFW             Boolean   @default(false)
  winnerCount           Int       @default(3)
  winnersAnnounced      Boolean   @default(false)
  metadata              Json?
  createdAt             DateTime  @default(now())

  // Relations
  post        Post               @relation(fields: [postId], references: [id], onDelete: Cascade)
  submissions FanArtSubmission[]

  @@index([postId])
  @@map("fan_art_galleries")
}

model FanArtSubmission {
  id               String           @id @default(cuid())
  galleryId        String
  artistId         String
  title            String
  description      String?          @db.Text
  imageUrl         String
  thumbnailUrl     String?
  highResUrl       String?
  fileSize         Int?
  dimensions       Json?            // {width, height}
  medium           String?          // "digital", "traditional", "mixed"
  tools            String[]         // Software/materials used
  timeSpent        Int?             // In hours
  voteCount        Int              @default(0)
  avgRating        Float            @default(0)
  viewCount        Int              @default(0)
  featured         Boolean          @default(false)
  winner           Boolean          @default(false)
  winnerRank       Int?
  moderationStatus ModerationStatus @default(PENDING)
  moderationNotes  String?
  metadata         Json?
  createdAt        DateTime         @default(now())

  // Relations
  gallery FanArtGallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  artist  User          @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@index([galleryId])
  @@index([artistId])
  @@index([voteCount])
  @@map("fan_art_submissions")
}

// =====================================================
// MODERATION & SAFETY MODELS
// =====================================================

model Report {
  id             String           @id @default(cuid())
  reporterId     String
  reportedUserId String?
  reason         ReportReason
  subreason      String?
  description    String?          @db.Text
  evidence       Json?            // Screenshots, links, etc.
  status         ModerationStatus @default(PENDING)
  priority       Int              @default(0) // 0=low, 1=normal, 2=high, 3=urgent
  assignedTo     String?
  resolvedBy     String?
  resolvedAt     DateTime?
  resolution     String?          // "warning", "ban", "no_action", etc.
  resolutionNote String?          @db.Text
  appealable     Boolean          @default(true)
  entityType     String           // "user", "post", "comment", etc.
  entityId       String
  metadata       Json?
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  // Relations
  reporter    User  @relation("reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  resolver    User? @relation("resolver", fields: [resolvedBy], references: [id], onDelete: SetNull)

  @@index([status, priority])
  @@index([entityType, entityId])
  @@index([reporterId])
  @@index([reportedUserId])
  @@map("reports")
}

model AiModerationQueue {
  id                   String    @id @default(cuid())
  entityType           String    // "post", "comment", "message", "profile"
  entityId             String
  content              String?   @db.Text
  contentHash          String?   // For duplicate detection
  aiProvider           String    @default("openai") // "openai", "perspective", "custom"
  aiScore              Float?    // 0-1 probability of violation
  aiCategories         Json?     // Detected categories with scores
  aiReasons            Json?     // Detailed reasons
  confidence           Float?    // AI confidence level
  humanReviewRequired  Boolean   @default(false)
  autoActionTaken      String?   // "blocked", "shadow_banned", "flagged"
  reviewPriority       Int       @default(0)
  reviewedBy           String?
  reviewDecision       String?   // "approve", "reject", "escalate"
  reviewNotes          String?   @db.Text
  falsePositive        Boolean?  // For AI training
  processingTime       Int?      // In milliseconds
  createdAt            DateTime  @default(now())
  reviewedAt           DateTime?

  // Relations
  reviewer User? @relation("moderationReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@index([humanReviewRequired, reviewPriority, createdAt])
  @@index([entityType, entityId])
  @@index([aiScore])
  @@map("ai_moderation_queue")
}

model ModerationAction {
  id              String   @id @default(cuid())
  moderatorId     String
  targetUserId    String?
  targetContentId String?
  targetType      String   // "user", "post", "comment", etc.
  action          String   // "warn", "mute", "ban", "delete", etc.
  duration        Int?     // In hours
  reason          String
  details         String?  @db.Text
  evidence        Json?
  automated       Boolean  @default(false)
  reversedBy      String?
  reversedAt      DateTime?
  reverseReason   String?
  expiresAt       DateTime?
  createdAt       DateTime @default(now())

  @@index([targetUserId])
  @@index([targetType, targetContentId])
  @@index([moderatorId])
  @@index([action])
  @@map("moderation_actions")
}

model ContentFilter {
  id          String   @id @default(cuid())
  filterType  String   // "keyword", "regex", "ai_category"
  pattern     String
  action      String   // "block", "flag", "shadow_ban"
  severity    Int      @default(1) // 1-5
  category    String?  // "spam", "hate", "nsfw", etc.
  isActive    Boolean  @default(true)
  hitCount    Int      @default(0)
  lastHitAt   DateTime?
  createdBy   String
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@index([filterType, isActive])
  @@index([pattern])
  @@map("content_filters")
}

// =====================================================
// ADDITIONAL SUPPORT MODELS
// =====================================================

model MediaFile {
  id            String   @id @default(cuid())
  userId        String
  fileType      String   // "image", "video", "audio", "document"
  fileSize      BigInt
  mimeType      String?
  originalName  String?
  storagePath   String
  cdnUrl        String?
  thumbnailUrl  String?
  blurhash      String?  // For image placeholders
  duration      Int?     // For video/audio in seconds
  dimensions    Json?    // {width, height} for images/videos
  metadata      Json?    // EXIF data, video metadata, etc.
  processedAt   DateTime?
  processingError String?
  isPublic      Boolean  @default(true)
  accessCount   Int      @default(0)
  lastAccessedAt DateTime?
  createdAt     DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([fileType])
  @@index([createdAt])
  @@map("media_files")
}

model Experiment {
  id                 String   @id @default(cuid())
  name               String   @unique
  description        String?  @db.Text
  hypothesis         String?  @db.Text
  variants           Json     // Array of variant configurations
  control            String   // Control variant name
  metrics            Json     // Metrics to track
  targetingRules     Json?    // User targeting criteria
  trafficPercentage  Int      @default(100)
  status             String   @default("DRAFT") // "DRAFT", "RUNNING", "PAUSED", "COMPLETED"
  results            Json?    // Experiment results
  winner             String?  // Winning variant
  startedAt          DateTime?
  endedAt            DateTime?
  createdBy          String
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  assignments ExperimentAssignment[]

  @@index([status])
  @@index([startedAt, endedAt])
  @@map("experiments")
}

model ExperimentAssignment {
  id           String   @id @default(cuid())
  experimentId String
  userId       String
  variant      String
  converted    Boolean  @default(false)
  conversionData Json?
  assignedAt   DateTime @default(now())
  convertedAt  DateTime?

  // Relations
  experiment Experiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([experimentId, userId])
  @@index([experimentId, variant])
  @@index([userId])
  @@map("experiment_assignments")
}

model FeatureFlag {
  id                String   @id @default(cuid())
  flag              String   @unique
  name              String
  description       String?  @db.Text
  enabled           Boolean  @default(false)
  rolloutPercentage Int      @default(0)
  enabledForUsers   String[] // Specific user IDs
  enabledForRoles   String[] // User roles
  conditions        Json?    // Complex targeting rules
  metadata          Json?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  @@index([flag])
  @@map("feature_flags")
}

model SiteSetting {
  key         String   @id
  value       Json
  type        String   // "string", "number", "boolean", "json"
  category    String?
  description String?  @db.Text
  isPublic    Boolean  @default(false) // Visible to non-admins
  isEditable  Boolean  @default(true)
  validation  Json?    // Validation rules
  updatedBy   String?
  updatedAt   DateTime @default(now())

  // Relations
  updater User? @relation(fields: [updatedBy], references: [id], onDelete: SetNull)

  @@index([category])
  @@map("site_settings")
}

model AuditLog {
  id            String   @id @default(cuid())
  userId        String?
  action        AuditAction
  entityType    String
  entityId      String
  entityData    Json?    // Snapshot before change
  changedData   Json?    // What changed
  reason        String?
  ipAddress     String?
  userAgent     String?  @db.Text
  sessionId     String?
  requestId     String?  // For request tracing
  duration      Int?     // Operation duration in ms
  errorMessage  String?
  metadata      Json?
  createdAt     DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([action])
  @@index([entityType, entityId])
  @@index([createdAt])
  @@map("audit_logs")
}

model AnalyticsEvent {
  id         String   @id @default(cuid())
  eventName  String
  eventType  String   // "pageview", "click", "custom"
  userId     String?
  sessionId  String?
  properties Json?
  context    Json?    // Device, browser, location info
  timestamp  DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([eventName, timestamp(sort: Desc)])
  @@index([userId])
  @@index([sessionId])
  @@index([timestamp])
  @@map("analytics_events")
}

model SearchIndex {
  id            String    @id @default(cuid())
  entityType    String    // "post", "user", "comment", etc.
  entityId      String
  searchableText String   @db.Text
  title         String?
  description   String?
  tags          String[]
  boost         Float     @default(1) // Search ranking boost
  locale        String    @default("en")
  isPublic      Boolean   @default(true)
  lastIndexedAt DateTime  @default(now())
  metadata      Json?

  @@unique([entityType, entityId])
  @@index([entityType])
  @@fulltext([searchableText])
  @@map("search_index")
}

model CacheEntry {
  key         String   @id
  value       Json
  type        CacheType
  tags        String[]
  expiresAt   DateTime
  accessCount Int      @default(0)
  lastAccessedAt DateTime @default(now())
  createdAt   DateTime @default(now())

  @@index([type])
  @@index([expiresAt])
  @@index([tags])
  @@map("cache_entries")
}

model SystemHealth {
  id              String   @id @default(cuid())
  service         String   // "api", "websocket", "worker", etc.
  status          String   // "healthy", "degraded", "down"
  responseTime    Float?   // In ms
  errorRate       Float?   // Percentage
  throughput      Float?   // Requests per second
  cpuUsage        Float?
  memoryUsage     Float?
  diskUsage       Float?
  activeUsers     Int?
  queueDepth      Int?
  metadata        Json?
  checkedAt       DateTime @default(now())

  @@index([service, checkedAt])
  @@map("system_health")
}

model RateLimitTracker {
  id          String   @id @default(cuid())
  identifier  String   // IP, userId, apiKey
  endpoint    String
  windowStart DateTime
  requests    Int      @default(1)
  blocked     Boolean  @default(false)

  @@unique([identifier, endpoint, windowStart])
  @@index([identifier])
  @@index([windowStart])
  @@map("rate_limit_tracker")
}

// Note: The following cannot be directly represented in Prisma but should be implemented:
// 
// 1. Database Views for:
//    - trending_posts (materialized view)
//    - top_creators (materialized view)
//    - active_groups (materialized view)
//    - user_reputation_scores (view)
//
// 2. Database Functions for:
//    - calculate_user_level(experience INT)
//    - calculate_engagement_rate(post_id UUID)
//    - update_post_stats(post_id UUID)
//    - calculate_reputation_score(user_id UUID)
//
// 3. Database Triggers for:
//    - Auto-update timestamps
//    - Update denormalized counts
//    - Level progression checks
//    - Achievement progress tracking
//
// 4. Indexes for Performance:
//    - Composite indexes for complex queries
//    - Partial indexes for filtered queries
//    - GIN indexes for JSON/Array searches
//
// 5. Partitioning Strategy:
//    - Time-based partitioning for analytics_events
//    - Time-based partitioning for activity_streams
//    - List partitioning for audit_logs by action type
//
// 6. Database Extensions:
//    - pg_trgm for fuzzy text search
//    - pgcrypto for encryption
//    - uuid-ossp for UUID generation
//
// These should be implemented via raw SQL migrations or database management tools.
