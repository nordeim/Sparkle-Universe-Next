// =====================================================
// Sparkle Universe Complete Prisma Schema
// Version 2.0 - Full Feature Implementation
// =====================================================

generator client {
  provider        = "prisma-client-js"
  previewFeatures = ["jsonProtocol", "fullTextSearch", "fullTextIndex"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// =====================================================
// ENUMS
// =====================================================

enum UserRole {
  USER
  MODERATOR
  ADMIN
  CREATOR
}

enum NotificationType {
  POST_LIKED
  POST_COMMENTED
  COMMENT_LIKED
  USER_FOLLOWED
  ACHIEVEMENT_UNLOCKED
  LEVEL_UP
  MENTION
  SYSTEM
  GROUP_INVITE
  GROUP_POST
  EVENT_REMINDER
  WATCH_PARTY_INVITE
  DIRECT_MESSAGE
  YOUTUBE_PREMIERE
  QUEST_COMPLETE
  TRADE_REQUEST
}

enum ReactionType {
  LIKE
  LOVE
  FIRE
  SPARKLE
  MIND_BLOWN
  LAUGH
  CRY
  ANGRY
}

enum ReportReason {
  SPAM
  INAPPROPRIATE
  HARASSMENT
  MISINFORMATION
  COPYRIGHT
  OTHER
}

enum ModerationStatus {
  PENDING
  APPROVED
  REJECTED
  ESCALATED
  AUTO_APPROVED
}

enum ContentType {
  BLOG
  LIVE_BLOG
  POLL
  VIDEO_REVIEW
  FAN_ART
  THEORY_THREAD
  SERIES
}

enum BadgeRarity {
  COMMON
  UNCOMMON
  RARE
  EPIC
  LEGENDARY
  MYTHIC
}

enum QuestType {
  DAILY
  WEEKLY
  MONTHLY
  SPECIAL
  ACHIEVEMENT
}

enum QuestStatus {
  AVAILABLE
  IN_PROGRESS
  COMPLETED
  CLAIMED
  EXPIRED
}

enum TradeStatus {
  PENDING
  ACCEPTED
  REJECTED
  CANCELLED
  EXPIRED
}

enum MessageStatus {
  SENT
  DELIVERED
  READ
}

enum EventType {
  WATCH_PARTY
  COMMUNITY_MEETUP
  CONTEST
  PREMIERE
  AMA
  SPECIAL
}

enum GroupVisibility {
  PUBLIC
  PRIVATE
  INVITE_ONLY
}

enum GroupMemberRole {
  MEMBER
  MODERATOR
  ADMIN
  OWNER
}

// =====================================================
// CORE MODELS
// =====================================================

model User {
  id              String    @id @default(cuid())
  email           String    @unique
  username        String    @unique
  hashedPassword  String?
  emailVerified   DateTime?
  image           String?
  bio             String?
  role            UserRole  @default(USER)
  verified        Boolean   @default(false)
  banned          Boolean   @default(false)
  banReason       String?
  banExpiresAt    DateTime?
  experience      Int       @default(0)
  level           Int       @default(1)
  sparklePoints   Int       @default(0)
  premiumPoints   Int       @default(0)
  lastSeenAt      DateTime?
  onlineStatus    Boolean   @default(false)
  createdAt       DateTime  @default(now())
  updatedAt       DateTime  @updatedAt

  // Relations
  accounts              Account[]
  sessions              Session[]
  profile               Profile?
  posts                 Post[]
  comments              Comment[]
  reactions             Reaction[]
  following             Follow[]             @relation("follower")
  followers             Follow[]             @relation("following")
  achievements          UserAchievement[]
  notifications         Notification[]       @relation("notificationUser")
  notificationsSent     Notification[]       @relation("notificationActor")
  xpLogs                XpLog[]
  currencyTransactions  CurrencyTransaction[]
  inventory             UserInventory[]
  tradesInitiated       Trade[]              @relation("tradeInitiator")
  tradesReceived        Trade[]              @relation("tradeRecipient")
  questProgress         UserQuest[]
  youtubeChannels       YoutubeChannel[]
  hostedWatchParties    WatchParty[]
  watchPartyParticipants WatchPartyParticipant[]
  videoClips            VideoClip[]
  playlists             Playlist[]
  playlistItems         PlaylistItem[]
  groupsOwned           Group[]
  groupMemberships      GroupMember[]
  eventsHosted          Event[]
  eventAttendances      EventAttendee[]
  conversationsCreated  Conversation[]
  conversationParticipants ConversationParticipant[]
  messages              Message[]
  messageReads          MessageRead[]
  websocketSessions     WebsocketSession[]
  chatRoomsCreated      ChatRoom[]
  chatMessages          ChatMessage[]
  collaborativeSpacesOwned CollaborativeSpace[]
  spaceCollaborations   SpaceCollaborator[]
  activityStreams       ActivityStream[]
  fanArtSubmissions     FanArtSubmission[]
  mediaFiles            MediaFile[]
  experimentAssignments ExperimentAssignment[]
  moderationReviews     AiModerationQueue[]   @relation("moderationReviewer")
  reports               Report[]              @relation("reporter")
  reportResolutions     Report[]              @relation("resolver")
  siteSettingUpdates    SiteSetting[]
  postSeries            PostSeries[]

  @@index([email])
  @@index([username])
  @@index([role])
  @@index([level])
  @@index([onlineStatus])
  @@index([sparklePoints])
}

model Profile {
  id                  String    @id @default(cuid())
  userId              String    @unique
  displayName         String?
  location            String?
  website             String?
  twitterUsername     String?
  youtubeChannelId    String?
  youtubeChannelUrl   String?
  youtubeChannelData  Json?
  bannerImage         String?
  themePreference     Json?
  notificationSettings Json     @default("{}")
  privacySettings     Json     @default("{}")
  featuredBadges      String[]
  customCss           String?
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([youtubeChannelId])
}

model Account {
  id                String    @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refreshToken      String?   @db.Text
  accessToken       String?   @db.Text
  expiresAt         BigInt?
  tokenType         String?
  scope             String?
  idToken           String?   @db.Text
  sessionState      String?
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
  @@index([userId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([sessionToken])
}

model Category {
  id           String   @id @default(cuid())
  name         String
  slug         String   @unique
  description  String?
  icon         String?
  color        String?
  parentId     String?
  postCount    Int      @default(0)
  displayOrder Int      @default(0)
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  parent   Category? @relation("CategoryHierarchy", fields: [parentId], references: [id], onDelete: SetNull)
  children Category[] @relation("CategoryHierarchy")
  posts    Post[]

  @@index([slug])
  @@index([parentId])
}

model Post {
  id                 String      @id @default(cuid())
  slug               String      @unique
  title              String      @db.VarChar(500)
  content            Json
  contentType        ContentType @default(BLOG)
  excerpt            String?
  coverImage         String?
  authorId           String
  categoryId         String?
  seriesId           String?
  seriesOrder        Int?
  published          Boolean     @default(false)
  featured           Boolean     @default(false)
  isDraft            Boolean     @default(true)
  version            Int         @default(1)
  parentVersionId    String?
  youtubeVideoId     String?
  youtubeVideoData   Json?
  views              Int         @default(0)
  readingTime        Int?
  metaDescription    String?
  scheduledPublishAt DateTime?
  publishedAt        DateTime?
  createdAt          DateTime    @default(now())
  updatedAt          DateTime    @updatedAt

  // Relations
  author         User             @relation(fields: [authorId], references: [id], onDelete: Cascade)
  category       Category?        @relation(fields: [categoryId], references: [id], onDelete: SetNull)
  series         PostSeries?      @relation(fields: [seriesId], references: [id], onDelete: SetNull)
  parentVersion  Post?            @relation("PostVersions", fields: [parentVersionId], references: [id], onDelete: SetNull)
  childVersions  Post[]           @relation("PostVersions")
  tags           PostTag[]
  comments       Comment[]
  reactions      Reaction[]
  poll           Poll?
  fanArtGallery  FanArtGallery?

  @@index([slug])
  @@index([authorId])
  @@index([categoryId])
  @@index([seriesId])
  @@index([published, publishedAt(sort: Desc)])
  @@index([featured])
  @@index([contentType])
  @@index([scheduledPublishAt])
}

model PostSeries {
  id          String   @id @default(cuid())
  title       String
  slug        String   @unique
  description String?
  authorId    String
  coverImage  String?
  completed   Boolean  @default(false)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  author User   @relation(fields: [authorId], references: [id], onDelete: Cascade)
  posts  Post[]

  @@index([authorId])
  @@index([slug])
}

model Tag {
  id          String   @id @default(cuid())
  name        String   @unique
  slug        String   @unique
  description String?
  color       String?
  postCount   Int      @default(0)
  createdAt   DateTime @default(now())

  // Relations
  posts PostTag[]

  @@index([name])
  @@index([slug])
}

model PostTag {
  postId    String
  tagId     String
  createdAt DateTime @default(now())

  // Relations
  post Post @relation(fields: [postId], references: [id], onDelete: Cascade)
  tag  Tag  @relation(fields: [tagId], references: [id], onDelete: Cascade)

  @@id([postId, tagId])
  @@index([postId])
  @@index([tagId])
}

model Comment {
  id                String    @id @default(cuid())
  content           String    @db.Text
  postId            String
  authorId          String
  parentId          String?
  youtubeTimestamp  Int?
  edited            Boolean   @default(false)
  editedAt          DateTime?
  deleted           Boolean   @default(false)
  pinned            Boolean   @default(false)
  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  // Relations
  post      Post       @relation(fields: [postId], references: [id], onDelete: Cascade)
  author    User       @relation(fields: [authorId], references: [id], onDelete: Cascade)
  parent    Comment?   @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
  replies   Comment[]  @relation("CommentReplies")
  reactions Reaction[]

  @@index([postId])
  @@index([authorId])
  @@index([parentId])
  @@index([youtubeTimestamp])
}

model Reaction {
  id        String       @id @default(cuid())
  type      ReactionType
  postId    String?
  commentId String?
  userId    String
  createdAt DateTime     @default(now())

  // Relations
  post    Post?    @relation(fields: [postId], references: [id], onDelete: Cascade)
  comment Comment? @relation(fields: [commentId], references: [id], onDelete: Cascade)
  user    User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([postId, userId, type])
  @@unique([commentId, userId, type])
  @@index([postId])
  @@index([commentId])
  @@index([userId])
}

model Follow {
  id          String   @id @default(cuid())
  followerId  String
  followingId String
  createdAt   DateTime @default(now())

  // Relations
  follower  User @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
  following User @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

  @@unique([followerId, followingId])
  @@index([followerId])
  @@index([followingId])
}

model Notification {
  id         String           @id @default(cuid())
  type       NotificationType
  userId     String
  actorId    String?
  entityId   String?
  entityType String?
  message    String           @db.Text
  data       Json?
  read       Boolean          @default(false)
  emailSent  Boolean          @default(false)
  pushSent   Boolean          @default(false)
  createdAt  DateTime         @default(now())

  // Relations
  user  User  @relation("notificationUser", fields: [userId], references: [id], onDelete: Cascade)
  actor User? @relation("notificationActor", fields: [actorId], references: [id], onDelete: SetNull)

  @@index([userId, read, createdAt(sort: Desc)])
  @@index([actorId])
  @@index([type])
}

// =====================================================
// GAMIFICATION MODELS
// =====================================================

model Achievement {
  id                   String      @id @default(cuid())
  code                 String      @unique
  name                 String
  description          String?
  icon                 String?
  animatedIcon         String?
  xpReward             Int         @default(0)
  sparklePointsReward  Int         @default(0)
  rarity               BadgeRarity @default(COMMON)
  category             String?
  criteria             Json?
  displayOrder         Int         @default(0)
  seasonal             Boolean     @default(false)
  expiresAt            DateTime?
  createdAt            DateTime    @default(now())

  // Relations
  userAchievements UserAchievement[]
}

model UserAchievement {
  id            String   @id @default(cuid())
  userId        String
  achievementId String
  unlockedAt    DateTime @default(now())
  progress      Json?
  showcased     Boolean  @default(false)

  // Relations
  user        User        @relation(fields: [userId], references: [id], onDelete: Cascade)
  achievement Achievement @relation(fields: [achievementId], references: [id], onDelete: Cascade)

  @@unique([userId, achievementId])
  @@index([userId])
  @@index([userId, showcased])
}

model XpLog {
  id        String   @id @default(cuid())
  userId    String
  amount    Int
  reason    String?
  metadata  Json?
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
}

model CurrencyTransaction {
  id              String   @id @default(cuid())
  userId          String
  amount          Int
  currencyType    String
  transactionType String
  description     String?
  referenceId     String?
  referenceType   String?
  balanceAfter    Int
  createdAt       DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([transactionType])
}

model StoreItem {
  id                 String    @id @default(cuid())
  sku                String    @unique
  name               String
  description        String?
  category           String
  priceSparkle       Int?
  pricePremium       Int?
  discountPercentage Int       @default(0)
  previewUrl         String?
  data               Json?
  limitedEdition     Boolean   @default(false)
  stockRemaining     Int?
  availableFrom      DateTime?
  availableUntil     DateTime?
  createdAt          DateTime  @default(now())
  updatedAt          DateTime  @updatedAt

  // Relations
  inventory UserInventory[]

  @@index([category])
  @@index([availableFrom, availableUntil])
}

model UserInventory {
  id         String    @id @default(cuid())
  userId     String
  itemId     String
  quantity   Int       @default(1)
  equipped   Boolean   @default(false)
  acquiredAt DateTime  @default(now())
  expiresAt  DateTime?

  // Relations
  user User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  item StoreItem @relation(fields: [itemId], references: [id], onDelete: Cascade)

  @@unique([userId, itemId])
  @@index([userId])
  @@index([userId, equipped])
}

model Trade {
  id              String      @id @default(cuid())
  initiatorId     String
  recipientId     String
  status          TradeStatus @default(PENDING)
  initiatorItems  String[]
  recipientItems  String[]
  initiatorPoints Int         @default(0)
  recipientPoints Int         @default(0)
  message         String?
  expiresAt       DateTime    @default(dbgenerated("(CURRENT_TIMESTAMP + interval '7 days')"))
  completedAt     DateTime?
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  initiator User @relation("tradeInitiator", fields: [initiatorId], references: [id], onDelete: Cascade)
  recipient User @relation("tradeRecipient", fields: [recipientId], references: [id], onDelete: Cascade)

  @@index([initiatorId, status])
  @@index([recipientId, status])
}

model Quest {
  id              String    @id @default(cuid())
  code            String    @unique
  name            String
  description     String?
  type            QuestType
  requirements    Json
  rewards         Json
  availableFrom   DateTime?
  availableUntil  DateTime?
  maxCompletions  Int       @default(1)
  createdAt       DateTime  @default(now())

  // Relations
  userQuests UserQuest[]
}

model UserQuest {
  id          String      @id @default(cuid())
  userId      String
  questId     String
  status      QuestStatus @default(AVAILABLE)
  progress    Json        @default("{}")
  startedAt   DateTime    @default(now())
  completedAt DateTime?
  claimedAt   DateTime?

  // Relations
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  quest Quest @relation(fields: [questId], references: [id], onDelete: Cascade)

  @@unique([userId, questId])
  @@index([userId, status])
  @@index([status])
}

model Leaderboard {
  id          String   @id @default(cuid())
  type        String
  periodStart DateTime
  periodEnd   DateTime
  data        Json
  createdAt   DateTime @default(now())

  @@unique([type, periodStart, periodEnd])
  @@index([type, periodEnd(sort: Desc)])
}

// =====================================================
// YOUTUBE INTEGRATION MODELS
// =====================================================

model YoutubeChannel {
  id                   String    @id @default(cuid())
  channelId            String    @unique
  userId               String?
  channelTitle         String?
  channelData          Json?
  subscriberCount      Int       @default(0)
  videoCount           Int       @default(0)
  lastVideoId          String?
  lastVideoPublishedAt DateTime?
  lastSyncedAt         DateTime?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([userId])
  @@index([channelId])
}

model YoutubeVideo {
  id           String    @id @default(cuid())
  videoId      String    @unique
  channelId    String
  title        String?   @db.VarChar(500)
  description  String?   @db.Text
  thumbnailUrl String?
  duration     Int?
  viewCount    BigInt    @default(0)
  likeCount    Int       @default(0)
  commentCount Int       @default(0)
  publishedAt  DateTime?
  metadata     Json?
  lastSyncedAt DateTime?
  createdAt    DateTime  @default(now())

  @@index([channelId])
  @@index([publishedAt(sort: Desc)])
}

model WatchParty {
  id             String    @id @default(cuid())
  hostId         String
  title          String
  description    String?
  youtubeVideoId String
  scheduledStart DateTime
  actualStart    DateTime?
  endedAt        DateTime?
  maxParticipants Int      @default(50)
  isPublic       Boolean   @default(true)
  chatEnabled    Boolean   @default(true)
  syncPlayback   Boolean   @default(true)
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  // Relations
  host         User                     @relation(fields: [hostId], references: [id], onDelete: Cascade)
  participants WatchPartyParticipant[]

  @@index([hostId])
  @@index([scheduledStart])
  @@index([isPublic, scheduledStart])
}

model WatchPartyParticipant {
  id               String    @id @default(cuid())
  partyId          String
  userId           String
  joinedAt         DateTime  @default(now())
  leftAt           DateTime?
  isActive         Boolean   @default(true)
  playbackPosition Int       @default(0)

  // Relations
  party WatchParty @relation(fields: [partyId], references: [id], onDelete: Cascade)
  user  User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([partyId, userId])
  @@index([partyId, isActive])
  @@index([userId])
}

model VideoClip {
  id             String   @id @default(cuid())
  youtubeVideoId String
  creatorId      String
  title          String
  startTime      Int
  endTime        Int
  description    String?
  tags           String[]
  viewCount      Int      @default(0)
  createdAt      DateTime @default(now())

  // Relations
  creator User @relation(fields: [creatorId], references: [id], onDelete: Cascade)

  @@index([youtubeVideoId])
  @@index([creatorId])
}

model Playlist {
  id              String   @id @default(cuid())
  title           String
  description     String?
  ownerId         String
  isCollaborative Boolean  @default(false)
  isPublic        Boolean  @default(true)
  coverImage      String?
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  // Relations
  owner User           @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  items PlaylistItem[]

  @@index([ownerId])
  @@index([isPublic])
}

model PlaylistItem {
  id             String   @id @default(cuid())
  playlistId     String
  youtubeVideoId String
  addedBy        String
  position       Int
  note           String?
  addedAt        DateTime @default(now())

  // Relations
  playlist Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  user     User     @relation(fields: [addedBy], references: [id], onDelete: Cascade)

  @@unique([playlistId, position])
  @@index([playlistId])
  @@index([addedBy])
}

// =====================================================
// SOCIAL FEATURES MODELS
// =====================================================

model Group {
  id           String          @id @default(cuid())
  name         String
  slug         String          @unique
  description  String?
  bannerImage  String?
  icon         String?
  ownerId      String
  visibility   GroupVisibility @default(PUBLIC)
  memberCount  Int             @default(1)
  postCount    Int             @default(0)
  rules        String?         @db.Text
  tags         String[]
  settings     Json            @default("{}")
  createdAt    DateTime        @default(now())
  updatedAt    DateTime        @updatedAt

  // Relations
  owner   User          @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  members GroupMember[]
  events  Event[]

  @@index([slug])
  @@index([ownerId])
  @@index([visibility])
}

model GroupMember {
  id        String          @id @default(cuid())
  groupId   String
  userId    String
  role      GroupMemberRole @default(MEMBER)
  joinedAt  DateTime        @default(now())
  invitedBy String?

  // Relations
  group Group @relation(fields: [groupId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([groupId, userId])
  @@index([groupId, role])
  @@index([userId])
}

model Event {
  id               String    @id @default(cuid())
  title            String
  description      String?
  type             EventType
  hostId           String
  groupId          String?
  locationName     String?
  locationUrl      String?
  bannerImage      String?
  startTime        DateTime
  endTime          DateTime
  timezone         String    @default("UTC")
  maxAttendees     Int?
  isPublic         Boolean   @default(true)
  requiresApproval Boolean   @default(false)
  tags             String[]
  metadata         Json?
  createdAt        DateTime  @default(now())
  updatedAt        DateTime  @updatedAt

  // Relations
  host      User            @relation(fields: [hostId], references: [id], onDelete: Cascade)
  group     Group?          @relation(fields: [groupId], references: [id], onDelete: Cascade)
  attendees EventAttendee[]

  @@index([hostId])
  @@index([groupId])
  @@index([startTime])
  @@index([isPublic, startTime])
}

model EventAttendee {
  id          String    @id @default(cuid())
  eventId     String
  userId      String
  status      String    @default("INTERESTED")
  approved    Boolean   @default(true)
  checkInTime DateTime?
  createdAt   DateTime  @default(now())

  // Relations
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([eventId, status])
  @@index([userId])
}

model Conversation {
  id           String   @id @default(cuid())
  isGroup      Boolean  @default(false)
  title        String?
  encryptedKey String?  @db.Text
  createdBy    String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  // Relations
  creator      User                      @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  participants ConversationParticipant[]
  messages     Message[]

  @@index([createdBy])
}

model ConversationParticipant {
  id                 String    @id @default(cuid())
  conversationId     String
  userId             String
  joinedAt           DateTime  @default(now())
  leftAt             DateTime?
  isAdmin            Boolean   @default(false)
  lastReadAt         DateTime?
  notificationsMuted Boolean   @default(false)

  // Relations
  conversation Conversation @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  user         User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([conversationId, userId])
  @@index([conversationId])
  @@index([userId])
}

model Message {
  id           String    @id @default(cuid())
  conversationId String
  senderId     String
  content      String?   @db.Text
  messageType  String    @default("TEXT")
  metadata     Json?
  edited       Boolean   @default(false)
  editedAt     DateTime?
  deleted      Boolean   @default(false)
  createdAt    DateTime  @default(now())

  // Relations
  conversation Conversation  @relation(fields: [conversationId], references: [id], onDelete: Cascade)
  sender       User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
  reads        MessageRead[]

  @@index([conversationId, createdAt(sort: Desc)])
  @@index([senderId])
}

model MessageRead {
  messageId String
  userId    String
  readAt    DateTime @default(now())

  // Relations
  message Message @relation(fields: [messageId], references: [id], onDelete: Cascade)
  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@id([messageId, userId])
  @@index([userId])
}

// =====================================================
// REAL-TIME SUPPORT MODELS
// =====================================================

model WebsocketSession {
  id          String   @id @default(cuid())
  userId      String
  socketId    String   @unique
  ipAddress   String?
  userAgent   String?  @db.Text
  connectedAt DateTime @default(now())
  lastPingAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([socketId])
}

model ChatRoom {
  id          String   @id @default(cuid())
  name        String
  slug        String   @unique
  description String?
  topic       String?
  isPublic    Boolean  @default(true)
  maxUsers    Int      @default(100)
  activeUsers Int      @default(0)
  createdBy   String
  createdAt   DateTime @default(now())

  // Relations
  creator  User          @relation(fields: [createdBy], references: [id], onDelete: Cascade)
  messages ChatMessage[]

  @@index([slug])
  @@index([isPublic])
}

model ChatMessage {
  id        String    @id @default(cuid())
  roomId    String
  userId    String
  content   String    @db.Text
  replyToId String?
  edited    Boolean   @default(false)
  deleted   Boolean   @default(false)
  createdAt DateTime  @default(now())

  // Relations
  room    ChatRoom     @relation(fields: [roomId], references: [id], onDelete: Cascade)
  user    User         @relation(fields: [userId], references: [id], onDelete: Cascade)
  replyTo ChatMessage? @relation("ChatMessageReplies", fields: [replyToId], references: [id], onDelete: SetNull)
  replies ChatMessage[] @relation("ChatMessageReplies")

  @@index([roomId, createdAt(sort: Desc)])
  @@index([userId])
}

model CollaborativeSpace {
  id               String   @id @default(cuid())
  type             String
  title            String
  ownerId          String
  content          Json?
  version          Int      @default(1)
  isPublic         Boolean  @default(false)
  maxCollaborators Int      @default(10)
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  // Relations
  owner         User                @relation(fields: [ownerId], references: [id], onDelete: Cascade)
  collaborators SpaceCollaborator[]

  @@index([ownerId])
  @@index([type])
}

model SpaceCollaborator {
  id       String   @id @default(cuid())
  spaceId  String
  userId   String
  canEdit  Boolean  @default(true)
  joinedAt DateTime @default(now())

  // Relations
  space CollaborativeSpace @relation(fields: [spaceId], references: [id], onDelete: Cascade)
  user  User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([spaceId, userId])
  @@index([spaceId])
  @@index([userId])
}

model ActivityStream {
  id         String   @id @default(cuid())
  userId     String
  action     String
  entityType String
  entityId   String
  metadata   Json?
  visibility String   @default("PUBLIC")
  createdAt  DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, createdAt(sort: Desc)])
  @@index([entityType, entityId])
}

// =====================================================
// CONTENT VARIATION MODELS
// =====================================================

model Poll {
  id              String   @id @default(cuid())
  postId          String   @unique
  question        String   @db.Text
  multipleChoice  Boolean  @default(false)
  anonymousVoting Boolean  @default(false)
  closeAt         DateTime?
  createdAt       DateTime @default(now())

  // Relations
  post    Post         @relation(fields: [postId], references: [id], onDelete: Cascade)
  options PollOption[]

  @@index([postId])
}

model PollOption {
  id           String   @id @default(cuid())
  pollId       String
  optionText   String   @db.Text
  displayOrder Int
  voteCount    Int      @default(0)

  // Relations
  poll  Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  votes PollVote[]

  @@index([pollId])
}

model PollVote {
  id        String   @id @default(cuid())
  pollId    String
  optionId  String
  userId    String
  createdAt DateTime @default(now())

  // Relations
  poll   Poll       @relation(fields: [pollId], references: [id], onDelete: Cascade)
  option PollOption @relation(fields: [optionId], references: [id], onDelete: Cascade)
  user   User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([pollId, userId, optionId])
  @@index([pollId])
  @@index([userId])
}

model FanArtGallery {
  id                    String   @id @default(cuid())
  postId                String   @unique
  submissionDeadline    DateTime?
  votingEnabled         Boolean  @default(true)
  maxSubmissionsPerUser Int      @default(3)
  createdAt             DateTime @default(now())

  // Relations
  post        Post               @relation(fields: [postId], references: [id], onDelete: Cascade)
  submissions FanArtSubmission[]
}

model FanArtSubmission {
  id           String   @id @default(cuid())
  galleryId    String
  artistId     String
  title        String
  description  String?
  imageUrl     String
  thumbnailUrl String?
  voteCount    Int      @default(0)
  featured     Boolean  @default(false)
  createdAt    DateTime @default(now())

  // Relations
  gallery FanArtGallery @relation(fields: [galleryId], references: [id], onDelete: Cascade)
  artist  User          @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@index([galleryId])
  @@index([artistId])
}

// =====================================================
// ADDITIONAL SUPPORT MODELS
// =====================================================

model MediaFile {
  id           String   @id @default(cuid())
  userId       String
  fileType     String
  fileSize     BigInt
  mimeType     String?
  originalName String?
  storagePath  String
  cdnUrl       String?
  thumbnailUrl String?
  metadata     Json?
  createdAt    DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([fileType])
}

model Experiment {
  id                 String   @id @default(cuid())
  name               String   @unique
  description        String?
  hypothesis         String?  @db.Text
  variants           Json
  targetingRules     Json?
  trafficPercentage  Int      @default(100)
  status             String   @default("DRAFT")
  startedAt          DateTime?
  endedAt            DateTime?
  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  // Relations
  assignments ExperimentAssignment[]

  @@index([status])
  @@index([startedAt, endedAt])
}

model ExperimentAssignment {
  id           String   @id @default(cuid())
  experimentId String
  userId       String
  variant      String
  assignedAt   DateTime @default(now())

  // Relations
  experiment Experiment @relation(fields: [experimentId], references: [id], onDelete: Cascade)
  user       User       @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([experimentId, userId])
  @@index([experimentId])
  @@index([userId])
}

model AiModerationQueue {
  id                   String    @id @default(cuid())
  entityType           String
  entityId             String
  content              String?   @db.Text
  aiScore              Float?
  aiReasons            Json?
  humanReviewRequired  Boolean   @default(false)
  reviewedBy           String?
  reviewDecision       String?
  reviewNotes          String?   @db.Text
  createdAt            DateTime  @default(now())
  reviewedAt           DateTime?

  // Relations
  reviewer User? @relation("moderationReviewer", fields: [reviewedBy], references: [id], onDelete: SetNull)

  @@index([humanReviewRequired, createdAt])
  @@index([entityType, entityId])
}

// =====================================================
// EXISTING MODELS (from original schema)
// =====================================================

model Report {
  id             String           @id @default(cuid())
  reporterId     String
  reason         ReportReason
  description    String?          @db.Text
  status         ModerationStatus @default(PENDING)
  resolvedBy     String?
  resolvedAt     DateTime?
  resolutionNote String?          @db.Text
  entityType     String
  entityId       String
  createdAt      DateTime         @default(now())
  updatedAt      DateTime         @updatedAt

  // Relations
  reporter User  @relation("reporter", fields: [reporterId], references: [id], onDelete: Cascade)
  resolver User? @relation("resolver", fields: [resolvedBy], references: [id], onDelete: SetNull)

  @@index([status])
  @@index([entityType, entityId])
}

model SiteSetting {
  key         String   @id
  value       Json
  description String?
  category    String?
  updatedBy   String?
  updatedAt   DateTime @default(now())

  // Relations
  updater User? @relation(fields: [updatedBy], references: [id], onDelete: SetNull)
}

model FeatureFlag {
  id                String   @id @default(cuid())
  flag              String   @unique
  enabled           Boolean  @default(false)
  rolloutPercentage Int      @default(0)
  conditions        Json?
  description       String?
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt
}

model AnalyticsEvent {
  id         String   @id @default(cuid())
  eventName  String
  userId     String?
  sessionId  String?
  properties Json?
  timestamp  DateTime @default(now())

  // Relations
  user User? @relation(fields: [userId], references: [id], onDelete: SetNull)

  @@index([eventName, timestamp(sort: Desc)])
  @@index([userId])
  @@index([sessionId])
}

model SearchIndexQueue {
  id          String    @id @default(cuid())
  entityType  String
  entityId    String
  action      String
  processed   Boolean   @default(false)
  error       String?   @db.Text
  createdAt   DateTime  @default(now())
  processedAt DateTime?

  @@index([processed, createdAt])
}

// Note: The following SQL-specific features cannot be directly represented in Prisma:
// - Materialized views (trending_posts, top_creators, active_groups)
// - Custom functions (update_updated_at_column, calculate_user_level, etc.)
// - Triggers (update timestamps, level checks, etc.)
// - Custom constraints beyond basic ones
// These would need to be implemented via:
// 1. Raw SQL migrations for database-level features
// 2. Application-level logic for business rules
// 3. Scheduled jobs for materialized view refreshes
