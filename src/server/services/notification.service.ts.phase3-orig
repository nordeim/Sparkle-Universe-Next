// src/server/services/notification.service.ts (enhanced)
import { PrismaClient, NotificationType } from '@prisma/client'
import { eventService } from './event.service'

export class NotificationService {
  constructor(private db: PrismaClient) {}

  async createNotification(params: {
    type: string
    userId: string
    actorId?: string
    entityId?: string
    entityType?: string
    title: string
    message: string
    data?: any
    imageUrl?: string
    actionUrl?: string
    priority?: number
  }) {
    try {
      // Check user notification preferences
      const prefs = await this.db.notificationPreference.findUnique({
        where: { userId: params.userId },
      })

      // Check if this notification type is enabled
      const notificationTypeKey = this.getPreferenceKey(params.type)
      if (prefs && notificationTypeKey && !prefs[notificationTypeKey]) {
        return null // User has disabled this notification type
      }

      // Check for duplicate notifications
      const recentDuplicate = await this.db.notification.findFirst({
        where: {
          userId: params.userId,
          type: params.type as NotificationType,
          entityId: params.entityId,
          createdAt: {
            gte: new Date(Date.now() - 5 * 60 * 1000), // 5 minutes
          },
        },
      })

      if (recentDuplicate) {
        return null // Prevent duplicate notifications
      }

      // Create notification
      const notification = await this.db.notification.create({
        data: {
          type: params.type as NotificationType,
          userId: params.userId,
          actorId: params.actorId,
          entityId: params.entityId,
          entityType: params.entityType,
          title: params.title,
          message: params.message,
          data: params.data,
          imageUrl: params.imageUrl,
          actionUrl: params.actionUrl,
          priority: params.priority || 0,
        },
        include: {
          actor: {
            include: {
              profile: true,
            },
          },
        },
      })

      // Emit real-time notification
      eventService.emit('notification.created', {
        userId: params.userId,
        notification,
      })

      // Queue email notification if enabled
      if (prefs?.emailNotifications) {
        await this.queueEmailNotification(notification)
      }

      // Queue push notification if enabled
      if (prefs?.pushNotifications) {
        await this.queuePushNotification(notification)
      }

      return notification
    } catch (error) {
      console.error('Failed to create notification:', error)
      return null
    }
  }

  async listNotifications(params: {
    userId: string
    limit: number
    cursor?: string
    unreadOnly?: boolean
    type?: string
  }) {
    const where: any = {
      userId: params.userId,
    }

    if (params.unreadOnly) {
      where.read = false
    }

    if (params.type) {
      where.type = params.type
    }

    const notifications = await this.db.notification.findMany({
      where,
      take: params.limit + 1,
      cursor: params.cursor ? { id: params.cursor } : undefined,
      include: {
        actor: {
          include: {
            profile: true,
          },
        },
      },
      orderBy: [
        { priority: 'desc' },
        { createdAt: 'desc' },
      ],
    })

    let nextCursor: string | undefined = undefined
    if (notifications.length > params.limit) {
      const nextItem = notifications.pop()
      nextCursor = nextItem!.id
    }

    return {
      items: notifications,
      nextCursor,
    }
  }

  async updatePreferences(userId: string, preferences: any) {
    return this.db.notificationPreference.upsert({
      where: { userId },
      update: preferences,
      create: {
        userId,
        ...preferences,
      },
    })
  }

  async getPreferences(userId: string) {
    const prefs = await this.db.notificationPreference.findUnique({
      where: { userId },
    })

    // Return defaults if no preferences exist
    return prefs || {
      emailNotifications: true,
      pushNotifications: true,
      postLikes: true,
      postComments: true,
      newFollowers: true,
      mentions: true,
      directMessages: true,
      groupInvites: true,
      eventReminders: true,
      marketingEmails: false,
      weeklyDigest: true,
    }
  }

  // ... rest of the methods from Phase 2 implementation
}
