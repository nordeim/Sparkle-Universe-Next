<!-- Path: PATCH_INSTRUCTIONS.md -->
# Creating & Applying Ready-to-Commit Patch Files (`git diff` / `git apply`)

This document explains how to produce a distributable patch (unified diff) that other developers can apply with `git apply`. It is ideal for sharing changes outside of PRs or for maintainers to accept a patch as-is.

> NOTE: Prefer PRs for most contributions. Use patches for offline workflows or when emailing diffs.

---

## Recommended workflow (author produces patch)

### 1) Prepare your changes locally
Work on a branch and stage everything you want in the patch:
```bash
git checkout -b feat/your-feature
# make edits, add files
git add -A
````

### 2) Create a unified diff patch (includes staged changes)

```bash
# Create patch for staged changes (preferred for a ready-to-apply patch)
git diff --staged --binary > my-change.patch
```

**Alternative: create a patch for the commits on your branch relative to main**

```bash
# Create patch that captures all commits on branch since origin/main
git fetch origin main
git diff --binary origin/main...HEAD > my-branch.patch
```

### 3) Verify the patch locally (dry-run)

```bash
# Check that the patch can be applied cleanly (no changes are made)
git apply --check my-change.patch
```

### 4) Include metadata (recommended)

Create a small `PATCH_README.md` alongside the patch with:

* Patch author
* Branch name
* Short description
* Files changed summary
* Test instructions

Example:

```
Patch: my-change.patch
Author: Your Name <you@example.com>
Branch: feat/your-feature
Summary: Adds X, modifies Y
How to test: npm ci, npm run dev, run tests
```

---

## Applying a patch (receiver / maintainer)

### 1) Inspect the patch

```bash
less my-change.patch
# or
git apply --stat my-change.patch    # shows summary
git apply --numstat my-change.patch  # shows file add/remove/line counts
```

### 2) Dry-run apply to ensure it will succeed

```bash
git apply --check my-change.patch
```

### 3) Apply the patch

```bash
# Apply changes to working tree
git apply my-change.patch

# If you want to also stage changes automatically for commit:
git apply --index my-change.patch  # writes to index
```

### 4) Verify & commit

```bash
git add -A
git commit -m "Apply patch: short description"
# Optionally sign the commit
git commit -S -m "Apply patch: short description"
git push origin your-branch
```

### 5) (Optional) Create PR

```bash
git push -u origin HEAD
# then open PR on GitHub using your branch
```

---

## Creating patches that add new files

* `git diff --staged` reliably includes new file contents (when files are staged).
* Use `--binary` to ensure binary files are included.
* `git apply` will create new files present in the patch. If `git apply` fails to create new files, try `git apply --index` then `git add` and `git commit`.

---

## Example minimal patch snippet

> The snippet below demonstrates the unified diff format for a new file addition. This is **example only**; generate real patches via the `git` commands above.

```
*** Begin Patch
*** Add File: docs/EXAMPLE.md
+<!-- Path: docs/EXAMPLE.md -->
+# Example doc
+
+This is an example file added by a patch.
+
*** End Patch
```

> Real patches generated by `git diff` will have unified diff style headers:
>
> ```
> diff --git a/docs/EXAMPLE.md b/docs/EXAMPLE.md
> new file mode 100644
> index 0000000..e69de29
> --- /dev/null
> +++ b/docs/EXAMPLE.md
> @@ -0,0 +1,4 @@
> +# Example doc
> +...
> ```

---

## Advanced tips & safety checks

* **Always run tests** before generating a patch: `npm run test` & `npm run lint`.
* **Keep patches small and focused**; one feature/fix per patch is much easier to review.
* **Sign your commits** locally if you want verifiable authorship: `git commit -S`.
* To include only specific files:

  ```bash
  git add path/to/file1 path/to/file2
  git diff --staged --binary > specific.patch
  ```
* To revert an applied patch:

  ```bash
  git apply -R my-change.patch   # reverse apply
  ```

---

## Troubleshooting

* **Patch apply fails with offset / fuzz**: likely the target repo changed. Rebase your branch onto the latest target base and regenerate the patch.
* **Binary files missing**: ensure `--binary` was used and the patch was generated with staged binary objects.
* **Permissions changed**: `git apply` may preserve file mode; verify `new file mode` in patch header.

---

## Security / Privacy notes for patches

* Do **not** include secrets or `.env` contents in patches.
* Use `.gitattributes` to exclude generated secrets from diffs.
* If a patch accidentally contains sensitive data, revoke exposed secrets immediately and notify maintainers.

---

## Template & checklist for authors (copy into patch README)

* [ ] I ran `npm run lint` and `npm run type-check`
* [ ] I ran `npm run test` (all unit tests pass)
* [ ] Migrations included (if DB changes)
* [ ] Patch generated with `git diff --staged --binary`
* [ ] `git apply --check` passes
* [ ] Patch file name: `YYYYMMDD-brief-description.patch`

---

## Summary

This method ensures contributors can produce portable, ready-to-apply patches for maintainers or offline workflows. For most public contributions, a GitHub fork + PR is still preferred, but this patch flow is reliable for alternate workflows.
